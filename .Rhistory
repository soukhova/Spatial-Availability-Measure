plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space
round(cor(t[, c('workers', "A_V_indexed_change")])[1,2],2)
knitr::opts_chunk$set(
echo = FALSE,
cache = TRUE,
warning = FALSE,
message = FALSE,
comment = '',
out.width = "1\\linewidth")
library(TTS2016R)
library(dplyr)
library(fitdistrplus)
library(ggplot2)
library(kableExtra)
library(patchwork)
library(sf)
library(scales)
library(ggpmisc)
library(ggrepel)
library(cowplot)
library(ggspatial)
library(spdep)
library(RColorBrewer)
library(tmap)
library(shadowtext)
library(grid)
# library(extrafont)
# font_import()
# loadfonts(device = "win")
options(scipen = 999)
#defining the spatial availability function
sp_avail <- function(x, o_id, d_id, pop, opp, r, f, alpha = 1){
o_id <- rlang::enquo(o_id)
d_id <- rlang::enquo(d_id)
pop <- rlang::enquo(pop)
opp <- rlang::enquo(opp)
r <- rlang::enquo(r)
f <- rlang::enquo(f)
sum_pop <- x %>%
dplyr::distinct(!!o_id,
.keep_all = TRUE) %>%
dplyr::mutate(sum_pop = !!r*(!!pop)^alpha) %>%
dplyr::pull(sum_pop) %>%
sum()
f_p <- dplyr::pull(x, !!r) * dplyr::pull(x, !!pop)^alpha / sum_pop
sum_impedance <- x %>%
dplyr::group_by(!!d_id) %>%
dplyr::summarize(sum_impedance = sum(!!f))
x <- x %>%
dplyr::left_join(sum_impedance,
by = rlang::as_name(d_id))
f_c <- dplyr::pull(x, !!f) / x$sum_impedance
x$f_c <- f_c
x$f_p <- f_p
sum_pa <- x %>%
dplyr::group_by(!!d_id) %>%
dplyr::summarize(sum_pa= sum(f_p * f_c))
x <- x %>%
dplyr::left_join(sum_pa,
by = rlang::as_name(d_id))
f_t <- (f_p * f_c) / dplyr::pull(x, sum_pa)
dplyr::pull(x, !!opp) * f_t
}
ggplot() +
geom_sf(data = toy_sim_zones %>% filter(type=="jobs"),
aes(size = number),
shape = 16,
color = "grey") +
geom_sf(data = toy_sim_zones %>% filter(type=="population"),
aes(size = number),
shape = 17,
color = "dimgrey") +
geom_sf_text(data = toy_sim_zones,
aes(label = id_short),
size = 3,
nudge_y = -600) +
scale_size(range = c(2, 4))  +
theme(legend.position = "none",
axis.text = element_blank(), axis.title = element_blank(),
panel.grid = element_blank(),
panel.background = element_rect(size = 1,
color = "black",
fill = NA))
ggsave("images/figure-1.png",
width = 3,
height = 2)
toy_sim_zones %>%
st_drop_geometry() %>%
dplyr::select(-id) %>%
mutate(fig = "") %>%
kable(format = "latex",
booktabs = TRUE,
col.names = c("ID", "Number", "Location Type", " "),
caption = "\\label{tab:toy-example}Summary description of synthetic example") %>%
#kable_styling(latex_options = c("scale_down")) %>%
column_spec(4,
image = "images/figure-1.png") %>%
collapse_rows(columns = 4,
latex_hline = "major",
valign = "middle")
# Calculate impedance function
beta <- 0.0015
toy_od_table <- toy_od_table %>%
mutate(f = exp(-beta * distance))
# using the origin-destination table (OD) of all origin to destination trips; filter in only jobs which are mean distance or less away from a population center and sum number of jobs available in each origin (population center)
c_accessibility <- toy_od_table %>%
mutate(A_ij = f * Jobs) %>%
group_by(Origin) %>%
summarise(A_i = sum(A_ij))
#pass conventional accessibility calculation into the spatial object (toy_sim_zones)
toy_sim_zones_access  <- toy_sim_zones %>%
left_join(c_accessibility,
by = c("id" = "Origin"))
# Plot the accessibility to employment in the example;
ggplot() +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "population"),
aes(fill = A_i, size = A_i, shape = type)) +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "jobs"),
aes(shape = type,
size = number),
fill = "black") +
geom_sf_text(data = toy_sim_zones_access , aes(label = id_short),
size = 2, nudge_y = -350) +
scale_shape_manual(values = c('population' = 24, 'jobs' = 21),
name = "Location Type",
labels=c("Population", "Jobs"),
guide = guide_legend(order = 2)) +
guides(shape =guide_legend(override.aes=list(size=5))) +
scale_size_continuous(range = c(2,6), name = expression(A["i"]), guide = "none") +
scale_fill_distiller(palette = "OrRd", direction = 1, name = expression(A["i"]),
limits = c(0, max(toy_sim_zones_access$A_i, na.rm = T)),
guide = guide_colorbar(order = 1)) +
theme(legend.position = "right", axis.text = element_blank(), axis.title = element_blank(),
panel.grid = element_blank(),
panel.background = element_rect(size = 1.5,
color = "grey",
fill = "gray95"))
# grouping the planning boundaries/municipalities so they make up the 20 regions in the TTS 2016. Note: st_buffer is used as there are small existing gaps between some boundaries. st_buffer of 10 m is enough to widen all boundaries and complete the st_union without issue.
group_ggh_pd_poly <- TTS2016R::ggh_pd %>% st_buffer(10) %>% group_by(REGION) %>%
summarize(REGION_name = first(REGION_name),
geometry = st_union((geometry)))
# creating an object of centroids for each region - this will be used to label polygons on the map
group_ggh_pd <- sf::st_centroid(group_ggh_pd_poly)
points <- sf::st_coordinates(group_ggh_pd) %>% data.frame()
group_ggh_pd <- cbind(group_ggh_pd, points)
## manually readjusting the X and Y coordinate of "County of Peterborough" and "Brant" as they overlap some cities
group_ggh_pd[group_ggh_pd$REGION_name=="Brant", "X"] <- 544000.0
group_ggh_pd[group_ggh_pd$REGION_name=="Brant", "Y"] <- 4767466
group_ggh_pd[group_ggh_pd$REGION_name=="Peterborough County", "Y"] <- 4921000
#plot
TTS_area_plot <- ggplot() +
geom_sf(data = TTS2016R::ggh_pd, color = "darkgray",
aes(fill = REGION_name)) +
scale_fill_manual(values = viridis::viridis(20)) +
geom_sf(data = group_ggh_pd_poly,
color = "black", fill = NA, size = 0.7) +
annotation_north_arrow(location = "tl", # north arrow for both the main plot
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot
height = unit(0.15, "cm")) +
geom_shadowtext(data = group_ggh_pd,
aes(x = X, y = Y, label = REGION_name),
size = 3.5,
nudge_y = 3000,
nudge_x = 2000) +
theme_void() +
theme(legend.position = "none",
axis.title = element_blank())
# ggsave("images/TTS16-survey-area.png")
#forming a complete descriptive statistic table
Statistics <- data.frame("Statistic" = c("Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max.", "NA's"))
Trips <- data.frame("Trips" = c(summary(od_ft_tt$trips)[[1]] %>% round(),
summary(od_ft_tt$trips)[[2]] %>% round(),
summary(od_ft_tt$trips)[[3]] %>% round(),
summary(od_ft_tt$trips)[[4]] %>% round(),
summary(od_ft_tt$trips)[[5]] %>% round(),
summary(od_ft_tt$trips)[[6]]%>% round(),
NA))
Travel_time <- data.frame("TT" = c(summary(od_ft_tt$travel_time)[[1]] %>% round(),
summary(od_ft_tt$travel_time)[[2]] %>% round(),
summary(od_ft_tt$travel_time)[[3]] %>% round(),
summary(od_ft_tt$travel_time)[[4]] %>% round(),
summary(od_ft_tt$travel_time)[[5]] %>% round(),
summary(od_ft_tt$travel_time)[[6]] %>% round(),
3507))
# TAZ_Area <- data.frame("TAZ_Area" = c(summary(ggh_taz$AREA)[[1]] %>% round(1),
#                                       summary(ggh_taz$AREA)[[2]] %>% round(1),
#                                       summary(ggh_taz$AREA)[[3]] %>% round(1),
#                                       summary(ggh_taz$AREA)[[4]] %>% round(1),
#                                       summary(ggh_taz$AREA)[[5]] %>% round(1),
#                                       summary(ggh_taz$AREA)[[6]] %>% round(1),
#                                       NA))
Workers <- data.frame("Workers" = c(summary(ggh_taz$workers)[[1]] %>% round(),
summary(ggh_taz$workers)[[2]] %>% round(),
summary(ggh_taz$workers)[[3]] %>% round(),
summary(ggh_taz$workers)[[4]] %>% round(),
summary(ggh_taz$workers)[[5]] %>% round(),
summary(ggh_taz$workers)[[6]] %>% round(),
NA))
Jobs <- data.frame("Jobs" = c(summary(ggh_taz$jobs)[[1]] %>% round(),
summary(ggh_taz$jobs)[[2]] %>% round(),
summary(ggh_taz$jobs)[[3]] %>% round(),
summary(ggh_taz$jobs)[[4]] %>% round(),
summary(ggh_taz$jobs)[[5]] %>% round(),
summary(ggh_taz$jobs)[[6]] %>% round(),
NA))
desc_stats <- cbind(Statistics, Trips, Travel_time, Workers, Jobs)
# #kable tabling
# desc_stats %>%
#   kable(format = "latex",
#         align="lrrrrrr",
#         booktabs = T,
#         col.names = c(" ", "(#)", "(min)", "(km^2)", "(#)", "(#)"),
#         caption = "\\label{tab:TTS-16-desc-stats}Descriptive statistics of the trips, calculated origin-destination car travel time, TAZ area, workers per TAZ, and jobs per TAZ.") %>%
#   add_header_above(c(" ", "Trips", "Travel Time", "Area", "Workers", "Jobs"), align = "r")%>%
#   kable_styling(full_width = "T",
#                 latex_options = c("scale_down"),
#                 position = "center")
TTS_area_plot <- TTS_area_plot + annotate(geom = "table",
x = 915000, y = 4880000,
label = list(desc_stats))
ggsave("images/TTS16-survey-area.png")
knitr::include_graphics("images/TTS16-survey-area.png")
# remove all NA trips from dataset and set all 0min travel times to 0.1 min
od_ft_tt  <- od_ft_tt %>%
filter( !is.na(travel_time)) %>%
mutate(travel_time = ifelse(travel_time == 0, 0.1, travel_time))
all_tt <- od_ft_tt  %>%
dplyr::select(trips, travel_time)
all_tt <- all_tt[rep(seq_len(dim(all_tt)[1]), all_tt$trips), 2]
# using fitdist function to fit a distribution using the default maximum likelihood estimation method and Nelder-Mead method for direct optimization
gamma_ <- fitdistrplus::fitdist(data=all_tt, "gamma", method="mle", optim.method="Nelder-Mead")
#lnorm_ <- fitdistrplus::fitdist(data=all_tt, "lnorm", method="mle", optim.method="Nelder-Mead")
#norm_ <-fitdistrplus::fitdist(data=all_tt, "norm", method="mle", optim.method="Nelder-Mead")
# #exp_ <- fitdistrplus::fitdist(data=all_tt, "exp", method="mle", optim.method="Nelder-Mead")
# pois_ <- fitdistrplus::fitdist(data=all_tt, "pois", method="mle", optim.method="Nelder-Mead")
# nbinom_ <- fitdistrplus::fitdist(data=all_tt, "nbinom", method="mle", optim.method="Nelder-Mead")
# geom_ <- fitdistrplus::fitdist(data=all_tt, "geom", method="mle", optim.method="Nelder-Mead")
# beta_ <- fitdistrplus::fitdist(data=all_tt, "beta", method="mle", optim.method="Nelder-Mead")
# logis_ <- fitdistrplus::fitdist(data=all_tt, "logis", method="mle", optim.method="Nelder-Mead")
# plot(gamma_)
# plot(pois_)
# plot(nbinom_)
# plot(geom_)
# plot(beta_)
# plot(logis_)
# For some reason plot(gamma_) does not play well with knitr, so instead we save the figure and then include it as a graphic in the following chunk
png("images/impedance_function.png")
plot(gamma_)
dev.off()
knitr::include_graphics("images/impedance_function.png")
#dgamma is the density plot for gamma function; adding values as "f" our impedance function
od_ft_tt <- od_ft_tt %>%
mutate(f = dgamma(travel_time, gamma_$estimate["shape"], gamma_$estimate["rate"]))
#select the toronto muni boundary
toronto_muni_bound <- group_ggh_pd_poly %>% filter(REGION_name == "Toronto")
#select the GTA boundary
GTA_bound <- group_ggh_pd_poly %>% filter(REGION_name == "Toronto" |
REGION_name == "Durham" |
REGION_name == "Halton" |
REGION_name == "Peel" |
REGION_name == "York" ) %>% st_union() %>% st_as_sf()
#indicate which zones are within or intersect the Toronto Municipality
TO_taz <- ggh_taz %>%
filter(st_intersects(., toronto_muni_bound, sparse = FALSE)[,1]) %>%
dplyr::select(GTA06, AREA, jobs) %>%
mutate(TAZToronto = "Yes")
#indicate which zones are within the GTA boundaries
GTA_taz <- ggh_taz %>%
filter(st_intersects(., GTA_bound, sparse = FALSE)[,1]) %>%
dplyr::select(GTA06, AREA, jobs) %>%
mutate(TAZGTA = "Yes")
# transfer calibrated impedance function values to OD matrix
od_ft_tt <- od_ft_tt %>%
mutate(f = dgamma(travel_time, gamma_$estimate["shape"], gamma_$estimate["rate"]))
#add the number of jobs and workers to the od_ft_tt matrix
od_ft <- od_ft_tt %>% merge(ggh_taz %>% dplyr::select(GTA06, workers) %>% st_drop_geometry(),
by.x = "Origin", by.y="GTA06", all.x = TRUE)
od_ft <- od_ft %>% merge(ggh_taz %>% dplyr::select(GTA06, jobs) %>% st_drop_geometry(),
by.x = "Destination", by.y="GTA06", all.x = TRUE)
#jobs at destinations IN Toronto and origins from anywhere; workers are associated with the origin (ggh) and jobs with the destination (Toronto)
TO_od_ft <- od_ft %>% filter(Destination %in% TO_taz$GTA06)
#calculate accessibility for workers from any origin to jobs in Toronto
TO_c_accessibility <- TO_od_ft %>%
mutate(TO_A_ij = f * jobs) %>%
group_by(Origin) %>%
summarise(TO_A_i = sum(TO_A_ij, na.rm = T),
trips_i = sum(trips, na.rm = T))
#Merge TO accessibly calculation to the ggh_taz:
TO_taz_acc <- ggh_taz %>% merge(TO_c_accessibility, by.x=c("GTA06"), by.y=c("Origin"), all.x=T)
# transfer calibrated impedance function values to OD matrix
od_ft_tt <- od_ft_tt %>%
mutate(f = dgamma(travel_time, gamma_$estimate["shape"], gamma_$estimate["rate"]))
#add the number of jobs and workers to the od_ft_tt matrix
od_ft <- od_ft_tt %>% merge(ggh_taz %>% dplyr::select(GTA06, workers) %>% st_drop_geometry(),
by.x = "Origin", by.y="GTA06", all.x = TRUE)
od_ft <- od_ft %>% merge(ggh_taz %>% dplyr::select(GTA06, jobs) %>% st_drop_geometry(),
by.x = "Destination", by.y="GTA06", all.x = TRUE)
#calculate accessibility for workers from any origin to jobs in Toronto
GGH_c_accessibility <- od_ft %>%
mutate(GGH_A_ij = f * jobs) %>%
group_by(Origin) %>%
summarise(GGH_A_i = sum(GGH_A_ij, na.rm = T),
trips_i = sum(trips, na.rm = T))
#Merge TO accessibly calculation to the ggh_taz:
GGH_taz_acc <- ggh_taz %>% merge(GGH_c_accessibility, by.x=c("GTA06"), by.y=c("Origin"), all.x=T)
#create the bounding box for the GGH region + a little extra
bbox_new1 <- st_bbox(group_ggh_pd_poly) # current bounding box
xrange <- bbox_new1$xmax - bbox_new1$xmin # range of x values
yrange <- bbox_new1$ymax - bbox_new1$ymin # range of y values
bbox_new1[1] <- bbox_new1[1] - (0.3 * xrange) # xmin - left
bbox_new1[3] <- bbox_new1[3] + (0.2 * xrange) # xmax - right
bbox_new1[2] <- bbox_new1[2] - (0.2 * yrange) # ymin - bottom
bbox_new1[4] <- bbox_new1[4] + (0.3 * yrange) # ymax - top
bbox_new <- bbox_new1 %>%  # take the bounding box ...
st_as_sfc()
#create the bounding box for the GTA region + a little extra
bbox_new1 <- st_bbox(GTA_bound) # current bounding box
xrange <- bbox_new1$xmax - bbox_new1$xmin # range of x values
yrange <- bbox_new1$ymax - bbox_new1$ymin # range of y values
bbox_new1[1] <- bbox_new1[1] - (0.0 * xrange) # xmin - left
bbox_new1[3] <- bbox_new1[3] - (0.1 * xrange) # xmax - right
bbox_new1[2] <- bbox_new1[2] + (0.0 * yrange) # ymin - bottom
bbox_new1[4] <- bbox_new1[4] - (0.3 * yrange) # ymax - top
bbox_GTA <- bbox_new1 %>%  # take the bounding box ...
st_as_sfc()
#create the bounding box for the Toronto region + a little extra
bbox_new1 <- st_bbox(toronto_muni_bound) # current bounding box
xrange <- bbox_new1$xmax - bbox_new1$xmin # range of x values
yrange <- bbox_new1$ymax - bbox_new1$ymin # range of y values
bbox_new1[1] <- bbox_new1[1] - (0.0 * xrange) # xmin - left
bbox_new1[3] <- bbox_new1[3] + (0.0 * xrange) # xmax - right
bbox_new1[2] <- bbox_new1[2] - (0.0 * yrange) # ymin - bottom
bbox_new1[4] <- bbox_new1[4] + (0.0 * yrange) # ymax - top
bbox_Toronto <- bbox_new1 %>%  # take the bounding box ...
st_as_sfc()
#calculate spatial availability
TO_od_ft <- TO_od_ft %>%
mutate(catch = 1) %>%
mutate(TO_V_ij = sp_avail(.,
o_id = Origin,
d_id = Destination,
pop = workers,
opp = jobs,
r = catch,
f = f))
#verify that the sum of all jobs is consistent with the number of jobs
sum(TO_od_ft$TO_V_ij, na.rm=T)
sum_jobs <- TO_od_ft %>% group_by(Destination) %>% summarise(jobs = mean(jobs))
sum(sum_jobs$jobs, na.rm = T)
#aggregating spatial availability
TO_availability <- TO_od_ft %>%
group_by(Origin) %>%
summarize(TO_V_i = sum(TO_V_ij),
TO_avgtt_i = mean(travel_time),
TO_avg_f_i = mean(f))
#Merge TO availability calculation to the TAZ sf object created for accessibility above:
TO_taz_acc <- TO_taz_acc %>% merge(TO_availability, by.x=c("GTA06"), by.y=c("Origin"), all.x=T)
#created filtered version - only TAZ within the Toronto and GTA boundaries
TO_taz_acc <- TO_taz_acc %>% merge(TO_taz %>% dplyr::select(GTA06,TAZToronto) %>% st_drop_geometry(), by="GTA06", all.x=TRUE)
TO_taz_acc <- TO_taz_acc %>% merge(GTA_taz %>% dplyr::select(GTA06,TAZGTA) %>% st_drop_geometry(), by="GTA06", all.x=TRUE)
TO_taz_acc_Torontofl <- dplyr::filter(TO_taz_acc, TAZToronto == "Yes")
TO_taz_acc_GTAfl <- dplyr::filter(TO_taz_acc, TAZGTA == "Yes")
#calculate spatial availability
GGH_od_ft <- od_ft %>%
mutate(catch = 1) %>%
mutate(GGH_V_ij = sp_avail(.,
o_id = Origin,
d_id = Destination,
pop = workers,
opp = jobs,
r = catch,
f = f))
#verify that the sum of all jobs is consistent with the number of jobs
sum(GGH_od_ft$GGH_V_ij, na.rm=T)
sum_jobs <- GGH_od_ft %>% group_by(Destination) %>% summarise(jobs = mean(jobs))
sum(sum_jobs$jobs, na.rm = T)
#aggregating spatial availability
GGH_availability <- GGH_od_ft %>%
group_by(Origin) %>%
summarize(GGH_V_i = sum(GGH_V_ij),
GGH_avgtt_i = mean(travel_time),
GGH_avg_f_i = mean(f))
#Merge TO availability calculation to the TAZ sf object created for accessibility above:
GGH_taz_acc <- GGH_taz_acc %>% merge(GGH_availability, by.x=c("GTA06"), by.y=c("Origin"), all.x=T)
## accessibility
#creating the main plot
mplot_access_TTS_GGH <- ggplot() +
geom_sf(data = GGH_taz_acc, aes(fill= GGH_A_i), color = NA) + #data
scale_fill_distiller(palette = "Spectral", #legend scale bar
name = expression(A["i"]),
na.value = "grey90",
limits = c( round(min(GGH_taz_acc$GGH_A_i, na.rm=T)), round(max(GGH_taz_acc$GGH_A_i, na.rm=T)) ),
breaks = c(round(min(GGH_taz_acc$GGH_A_i, na.rm=T)), 5000, 10000, 15000, 20000, round(max(GGH_taz_acc$GGH_A_i, na.rm=T))),
labels = c(round(min(GGH_taz_acc$GGH_A_i, na.rm=T)), 5000, 10000, 15000, 20000, round(max(GGH_taz_acc$GGH_A_i, na.rm=T)))) +
geom_sf(data = toronto_muni_bound, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
theme_void() +
theme(legend.position = c(1.15, 0.75),
plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space
# #main plot + adding the inset map.
mplot_access_TTS <- ggdraw(mplot_access_TTS_GGH) +
draw_plot({mplot_access_TTS_GGH + coord_sf(xlim = st_coordinates(bbox_Toronto)[c(1,2),1],
ylim = st_coordinates(bbox_Toronto)[c(2,3),2],
expand = FALSE) +
theme(legend.position = "none")},
x = 0.57, y = 0.00,  # The distance along a (0,1) x-axis (and y axis) to draw the left edge (the bottom edge) of the plot
width = 0.46, height = 0.46) # The width and height of the plot expressed as proportion of the entire ggdraw object
## spatial availability
mplot_SA_TTS_GGH <- ggplot() +
geom_sf(data = GGH_taz_acc, aes(fill= GGH_V_i), color = NA) + #data
scale_fill_distiller(palette = "Spectral", #legend scale bar
name =  expression(V["i"]),
na.value = "grey90",
limits = c( round(min(GGH_taz_acc$GGH_V_i, na.rm=T)), round(max(GGH_taz_acc$GGH_V_i, na.rm=T)) ),
breaks = c(round(min(GGH_taz_acc$GGH_V_i, na.rm=T)), 5000, 10000, 15000, round(max(GGH_taz_acc$GGH_V_i, na.rm=T))),
labels = c(round(min(GGH_taz_acc$GGH_V_i, na.rm=T)), 5000, 10000, 15000, round(max(GGH_taz_acc$GGH_V_i, na.rm=T)))) +
geom_sf(data = toronto_muni_bound, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
theme_void() +
theme(legend.position = c(1.15, 0.75),
plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space
# #main plot + adding the inset map.
mplot_SA_TTS <- ggdraw(mplot_SA_TTS_GGH) +
draw_plot({mplot_SA_TTS_GGH + coord_sf(xlim = st_coordinates(bbox_Toronto)[c(1,2),1],
ylim = st_coordinates(bbox_Toronto)[c(2,3),2],
expand = FALSE) +
theme(legend.position = "none")},
x = 0.57, y = 0.00,  # The distance along a (0,1) x-axis (and y axis) to draw the left edge (the bottom edge) of the plot
width = 0.46, height = 0.46) # The width and height of the plot expressed as proportion of the entire ggdraw object
mplot_access_TTS / mplot_SA_TTS
benchmark_GGH_V_i_workers <- GGH_taz_acc %>% st_drop_geometry() %>% summarise(avg_VO = sum(GGH_V_i, na.rm = TRUE)/sum(workers, na.rm = TRUE)) %>% as.numeric()
mplot_SApW_TTS_GGH <- ggplot() +
geom_sf(data = GGH_taz_acc, aes(fill= GGH_V_i/workers), color = NA) + #data
scale_fill_gradient2(low = "deepskyblue4",
mid = "ghostwhite",
high = "red", #legend scale bar
name = expression(v["i"]),
limits = c(0, round(max(GGH_taz_acc$GGH_V_i/GGH_taz_acc$workers, na.rm=TRUE))),
midpoint= benchmark_GGH_V_i_workers, #average V_i per capita
na.value = "grey90") +
geom_sf(data = toronto_muni_bound, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
theme_void() +
theme(legend.position = c(1.15, 0.75),
plot.margin = margin(t = 0, r = 0, b = 0, l = -80))# positing legend and clipping out white space
# #main plot + adding the inset map.
mplot_SApW_TTS <- ggdraw(mplot_SApW_TTS_GGH) +
draw_plot({mplot_SApW_TTS_GGH + coord_sf(xlim = st_coordinates(bbox_Toronto)[c(1,2),1],
ylim = st_coordinates(bbox_Toronto)[c(2,3),2],
expand = FALSE) +
theme(legend.position = "none")},
x = 0.57, y = 0.00,  # The distance along a (0,1) x-axis (and y axis) to draw the left edge (the bottom edge) of the plot
width = 0.46, height = 0.46) # The width and height of the plot expressed as proportion of the entire ggdraw object
mplot_SApW_TTS
#here we index (re-scale) the accessibility and spatial availability measures and split up the objects into POSITIVE change (i.e. when SA is higher than accessibility) and NEGATIVE change (i.e. when SA is lower than accessibility)
GGH_indexed_measures_ALL <- GGH_taz_acc %>%
mutate(A_indexed = GGH_A_i/(max(GGH_A_i, na.rm = TRUE))*100,
V_indexed = GGH_V_i/(max(GGH_V_i, na.rm = TRUE))*100,
A_V_indexed_change = A_indexed/V_indexed,
GGH_avg_f_i)
GGH_indexed_measures_over <- GGH_indexed_measures_ALL %>%
filter(A_V_indexed_change >= 1)
GGH_indexed_measures_under <- GGH_indexed_measures_ALL %>%
filter(A_V_indexed_change < 1 )
round(quantile(GGH_indexed_measures_under$A_V_indexed_change, probs = seq(0, 1, 0.05)) %>% data.frame() %>% slice(n=20),0)
round(quantile(GGH_indexed_measures_under$A_V_indexed_change, probs = seq(0, 1, 0.05)) %>% data.frame() %>% slice(n=21),0)
round(quantile(GGH_indexed_measures_under$A_V_indexed_change, probs = seq(0, 1, 0.05)) %>% data.frame() %>% slice(n=20),0)
quantile(GGH_indexed_measures_under$A_V_indexed_change, probs = seq(0, 1, 0.05))
round(quantile(GGH_indexed_measures_under$A_V_indexed_change, probs = seq(0, 1, 0.05)) %>% data.frame() %>% slice(n=1),0)
round(quantile(GGH_indexed_measures_under$A_V_indexed_change, probs = seq(0, 1, 0.05)) %>% data.frame() %>% slice(n=2),0)
round(quantile(GGH_indexed_measures_under$A_V_indexed_change, probs = seq(0, 1, 0.05)) %>% data.frame() %>% slice(n=2),6)
round(quantile(GGH_indexed_measures_under$A_V_indexed_change, probs = seq(0, 1, 0.05)) %>% data.frame() %>% slice(n=2),3)
round(quantile(GGH_indexed_measures_under$A_V_indexed_change, probs = seq(0, 1, 0.05)) %>% data.frame() %>% slice(n=1),3)
round(quantile(GGH_indexed_measures_under$A_V_indexed_change, probs = seq(0, 1, 0.05)) %>% data.frame() %>% slice(n=1),3)
percent(nrow(GGH_indexed_measures_over)/(nrow(GGH_indexed_measures_over) + nrow(GGH_indexed_measures_under)))
