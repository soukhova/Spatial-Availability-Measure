S <- od_tt %>%
left_join(LOS_j %>%
dplyr::select(j, LOS_j, opp, R_j),
by = "j") %>%
group_by(i) %>%
summarize(S_i = sum(opp.x * f), #first, hansen-type accessibility (unconstrained)
a_i = sum(LOS_j * f)) #second, shen/2SFCA (singly constrained),
od_tt2 <- merge(od_tt,
S,
by="i",
all.x = TRUE) %>%
transmute(i,
pop,
j,
opp,
tt,
f,
pop_f = pop * f,
jobs_f = opp * f,
S_i,
a_i) %>%
mutate(f = ifelse(f < 0.001, "< 0.001", round(f, 3)),
pop_f = ifelse(pop_f < 0.001, "< 0.001", round(pop_f, 3)),
jobs_f = ifelse(jobs_f < 0.001, "< 0.001", round(jobs_f, 3)))
colnames(od_tt2) = c("Origin", "Pop.", "Dest.", "Jobs", "TT", "f(TT)", "Pop * f(TT)", "Jobs * f(TT)", "S_i", "a_i") #, "BFCA_i")
#merge 1 and 2 and 3
od_tt3 <- rbind(od_tt1, od_tt2)
od_tt3 <- od_tt3  %>%
as_hux(scientific=TRUE)
#table with all the accessibility calculations
# Impedance parameter
b <- 0.1
# Calculate impedance function
od_tt1 <- od_tt %>% mutate(f = exp(-b * tt))
# Level of service
LOS_j <- od_tt1 %>%
group_by(j) %>%
summarize(opp = mean(opp),
R_j = sum(pop * f),
.groups = "drop") %>%
mutate(LOS_j = opp/R_j)
# Hansen- and Shen-type accessibility
S <- od_tt1 %>%
left_join(LOS_j %>%
dplyr::select(j, LOS_j, opp, R_j),
by = "j") %>%
group_by(i) %>%
summarize(S_i = sum(opp.x * f), #first, hansen-type accessibility (unconstrained)
a_i = sum(LOS_j * f)) #second, shen/2SFCA (singly constrained)
od_tt1 <- merge(od_tt1,
S,
by="i",
all.x = TRUE) %>%
transmute(i,
j,
pop,
opp,
tt,
f,
pop_f = pop * f,
jobs_f = opp * f,
S_i,
a_i)%>%
mutate(f = ifelse(f < 0.001, "< 0.001", round(f, 3)),
pop_f = ifelse(pop_f < 0.001, "< 0.001", round(pop_f, 3)),
jobs_f = ifelse(jobs_f < 0.001, "< 0.001", round(jobs_f, 3)))
colnames(od_tt1) = c("Origin",  "Dest.","Pop.", "Jobs", "TT", "f(TT)", "Pop * f(TT)", "Jobs * f(TT)", "S_i", "a_i") #, "BFCA_i")
od_tt1 <- t(od_tt1)
# Impedance parameter
b <- 0.6
# Calculate impedance function
od_tt2 <- od_tt %>% mutate(f = exp(-b * tt))
# Level of service
LOS_j <- od_tt2 %>%
group_by(j) %>%
summarize(opp = mean(opp),
R_j = sum(pop * f),
.groups = "drop") %>%
mutate(LOS_j = opp/R_j)
# Hansen- and Shen-type accessibility
S <- od_tt2 %>%
left_join(LOS_j %>%
dplyr::select(j, LOS_j, opp, R_j),
by = "j") %>%
group_by(i) %>%
summarize(S_i = sum(opp.x * f), #first, hansen-type accessibility (unconstrained)
a_i = sum(LOS_j * f)) #second, shen/2SFCA (singly constrained),
od_tt2 <- merge(od_tt2,
S,
by="i",
all.x = TRUE) %>%
transmute(f,
pop_f = pop * f,
jobs_f = opp * f,
S_i,
a_i) %>%
mutate(f = ifelse(f < 0.001, "< 0.001", round(f, 3)),
pop_f = ifelse(pop_f < 0.001, "< 0.001", round(pop_f, 3)),
jobs_f = ifelse(jobs_f < 0.001, "< 0.001", round(jobs_f, 3)))
colnames(od_tt2) = c("f(TT)", "Pop * f(TT)^1", "Jobs * f(TT)^1", "S_i^1", "a_i^1") #, "BFCA_i")
od_tt2 <- t(od_tt2)
# Reset impedance parameter
b <- 0.1
# Calculate impedance function
od_tt3 <- od_tt %>%
mutate(f = exp(-b * tt))
od_tt3 <- od_tt3 %>%
mutate(catch = 1) %>%
sp_avail_detailed(o_id = i, #spatial availability
d_id = j,
pop = pop,
opp = opp,
r = catch,
f = f,
alpha = 1) %>%
transmute(i,
f,
F_p = f_p,
F_c = f_c,
F_t = f_t,
V_ij)
V_i <- od_tt3 %>%
group_by(i) %>%
summarize(V_i = sum(V_ij))
od_tt3 <- od_tt3 %>%
left_join(V_i,
by = "i") %>% dplyr::select(-c(i,f)) %>%
mutate(F_p = ifelse(F_p < 0.001, "< 0.001", round(F_p, 3)),
F_c = ifelse(F_c < 0.001, "< 0.001", round(F_c, 3)),
F_t = ifelse(F_t < 0.001, "< 0.001", round(F_t, 3)),
V_ij = ifelse(V_ij < 0.001, "< 0.001", round(V_ij, 3)),
V_i = ifelse(V_i < 0.001, "< 0.001", round(V_i, 3)),)
colnames(od_tt3) <- c("F^p", "F^c", "F", "V_ij", "V_i")
od_tt3 <- t(od_tt3)
#merge 1 and 2 and 3
od_tt4 <- rbind(od_tt1, od_tt2, od_tt3)
rownames_od_tt4 <- c("Origin",
"Dest.", "Pop.", "Jobs", "TT",
"f(TT)", "Pop * f(TT)", "Jobs * f(TT)", "S_i", "a_i",
"f(TT)", "Pop * f(TT)", "Jobs * f(TT)", "S_i", "a_i",
"F^c", "F^p", "F", "V_ij", "V_i")
od_tt4 <- cbind(rownames_od_tt4, od_tt4)
od_tt4 <- od_tt4  %>%
as_hux()
table_toy  <- od_tt4 %>%
set_background_color(c(6:10,16:20), 1:10, "lightyellow") %>%
set_background_color(11:15, 1:10, "grey90") %>%
set_bold(1:2, everywhere) %>%
set_bottom_border(c(1,2,5,10,15,20), everywhere) %>%
set_right_border(everywhere, c(1,4,7,10), brdr(1, "solid", "grey")) %>%
set_align(1:20, 1, "left") %>%
set_align(1:20,  2:10, "center") %>%
set_number_format(c(6,10,11:15,16:18), everywhere, 3) %>% #the smaller numbers, have 3 decimals
set_number_format(c(7:9,19,20), everywhere, 1) %>% # the larger numbers, have 1 decimal
merge_cells(1, 2:4) %>% merge_cells(1, 5:7) %>% merge_cells(1, 8:10) %>%
set_caption("Summary description of synthetic example: Hansen-type accessibility $S_i$, Shen-type accessibility $a_i$, and spatial availability $V_i$ with beta = 0.1 (light yellow) and beta = 0.6 (light grey).") %>%
set_label("tab:synthetic-example") %>%
set_latex_float("h!") %>%
set_width(1.1)
font_size(table_toy) <- 7
table_toy[1:20,]
b<-0.6
data.frame(tt = seq(0, 110, 1)) %>%
mutate(f1 = exp(-0.1 * tt),
f2 = exp(-b * tt)) %>%
pivot_longer(cols = -tt,
names_to = "Function",
values_to = "f") %>%
mutate(Function = case_when(Function == "f1" ~ "beta = 0.1",
Function == "f2" ~ "beta = 0.6")) %>%
ggplot() +
xlab("TT") +
ylab("f(TT)") +
geom_line(aes(x = tt,
y = f,
color = Function)) +
theme_minimal()
V_i$V_i[1]/50000
V_i$V_i[2]/150000
V_i$V_i[3]/10000
# grouping the planning boundaries/municipalities so they make up the 20 regions in the TTS 2016. Note: st_buffer is used as there are small existing gaps between some boundaries. st_buffer of 100 m is enough to widen all boundaries and complete the st_union without issue.
group_ggh_pd_poly <- TTS2016R::ggh_pd %>% st_buffer(100) %>% group_by(REGION) %>%
summarize(REGION_name = first(REGION_name),
geometry = st_union((geometry)))
# creating an object of centroids for each region - this will be used to label polygons on the map
group_ggh_pd <- sf::st_centroid(group_ggh_pd_poly)
points <- sf::st_coordinates(group_ggh_pd) %>% data.frame()
group_ggh_pd <- cbind(group_ggh_pd, points)
## manually readjusting the X and Y coordinate of "County of Peterborough" and "Brant" as they overlap some cities
group_ggh_pd[group_ggh_pd$REGION_name=="Brant", "X"] <- 544000.0
group_ggh_pd[group_ggh_pd$REGION_name=="Brant", "Y"] <- 4767466
group_ggh_pd[group_ggh_pd$REGION_name=="Peterborough County", "Y"] <- 4921000
#plot
TTS_area_plot <- ggplot() +
geom_sf(data = TTS2016R::ggh_pd, color = "darkgray",
aes(fill = REGION_name)) +
scale_fill_manual(values = viridis::viridis(20)) +
geom_sf(data = group_ggh_pd_poly,
color = "black", fill = NA, size = 0.7) +
annotation_north_arrow(location = "tl", # north arrow for both the main plot
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot
height = unit(0.15, "cm")) +
geom_shadowtext(data = group_ggh_pd,
aes(x = X, y = Y, label = REGION_name),
size = 3.5,
nudge_y = 3000,
nudge_x = 2000) +
theme_void() +
theme(legend.position = "none",
axis.title = element_blank())
ggsave("images/TTS16-survey-area-notable.png")
{0.049787}/{0.223130 + 0.049787 + 0.000045}
{133,203.4}/{150,000}
{133203.4}/{150000}
library(tidyverse)
library(rgdal)
library(raster)
library(sf)
library(dplyr)
library(gdistance)
library(kableExtra)
library(data.table)
load("Simulated Example.RData")
View(Clinics_data)
View(Clinics_data)
# Clinics
sim_clinics <- st_sf(Clinics_data, geometry_clinics, stringsAsFactors = TRUE)
# Population centers
sim_population <- st_sf(Population_data, geometry_population, stringsAsFactors = TRUE)
distance_matrix <- round(pointDistance(st_coordinates(sim_population),
st_coordinates(sim_clinics),
type='Euclidean', lonlat = FALSE))
View(distance_matrix)
head(Clinics_data)
head(Population_data)
head(distance_matrix)
quantiles_d <- quantile(as.vector(distance_matrix), probs = c(0, 1/10, 3/10, 5/10, 7/10, 8/10, 9/10))
dist_threshold <- quantile(as.vector(distance_matrix), probs = c(0, 1/10, 3/10, 5/10, 7/10, 8/10, 9/10))[[5]]
distance_matrix_long <- as.data.table(distance_matrix)
names(distance_matrix_long) <- c('clinic_1', 'clinic_2', 'clinic_3')
distance_matrix_long$id <- Population_data$id
distance_matrix_long <- data.table::melt(distance_matrix_long, id.vars='id', variable.name = "dest", value.name = "dist")
distance_matrix_long <- left_join(distance_matrix_long, Population_data)
Clinics_data$id <- c('clinic_1', 'clinic_2', 'clinic_3')
distance_matrix_long$dest <- as.character(distance_matrix_long$dest)
long_matrix <- left_join(distance_matrix_long, Clinics_data, by=c('dest'='id'))
setDT(long_matrix)
head(long_matrix)
# Run only if binary function desired
# Change chunk option eval=TRUE to FALSE if impedance is Gaussian function
long_matrix <- long_matrix %>%
mutate(impedance = ifelse(dist <= dist_threshold, 1, 0))
# Run only if Gaussian function desired
# Change chunk option eval=FALSE to TRUE if impedance is Gaussian function
long_matrix <- long_matrix %>%
mutate(impedance = case_when(dist <= quantiles_d[1] ~ 0.945,
(dist > quantiles_d[1]) & (dist <= quantiles_d[3]) ~ 0.600,
(dist > quantiles_d[3]) & (dist <= quantiles_d[5]) ~ 0.242,
dist > quantiles_d[5] ~ 0))
sum_b1 <- long_matrix %>%
group_by(id) %>%
summarize(sum_b1 = sum(impedance))
sum_b1
sum_b2 <- long_matrix %>%
group_by(dest) %>%
summarize(sum_b2 = sum(impedance))
sum_b2
long_matrix <- long_matrix %>%
left_join(sum_b1, by = "id") %>%
left_join(sum_b2, by = "dest")
od_tt <- data.frame(o_id = c("A", "A", "A", "B", "B", "B", "C", "C", "C"), # Three origins
d_id = c("1", "2", "3", "1", "2", "3", "1", "2", "3"), # Three destinations
tt = c(15, 30, 100, 30, 15, 100, 100, 100, 15), # Travel time
pop = c(50000, 50000, 50000, 150000, 150000, 150000, 10000, 10000, 10000), # Population
opp = c(100000, 100000, 10000, 100000, 100000, 10000, 100000, 100000, 10000)) # Jobs
b <- 0.1
od_tt <- od_tt |>
mutate(f = exp(-b * tt))
od_tt
od_tt
S <- od_tt |>
group_by(o_id) |>
summarize(S = sum(opp * f),
.groups = "drop")
S
#defining the spatial availability function
sp_avail <- function(x, o_id, d_id, pop, opp, r, f, alpha = 1){
o_id <- rlang::enquo(o_id)
d_id <- rlang::enquo(d_id)
pop <- rlang::enquo(pop)
opp <- rlang::enquo(opp)
r <- rlang::enquo(r)
f <- rlang::enquo(f)
sum_pop <- x %>%
dplyr::distinct(!!o_id,
.keep_all = TRUE) %>%
dplyr::mutate(sum_pop = !!r*(!!pop)^alpha) %>%
dplyr::pull(sum_pop) %>%
sum()
f_p <- dplyr::pull(x, !!r) * dplyr::pull(x, !!pop)^alpha / sum_pop
sum_impedance <- x %>%
dplyr::group_by(!!d_id) %>%
dplyr::summarize(sum_impedance = sum(!!f))
x <- x %>%
dplyr::left_join(sum_impedance,
by = rlang::as_name(d_id))
f_c <- dplyr::pull(x, !!f) / x$sum_impedance
x$f_c <- f_c
x$f_p <- f_p
sum_pa <- x %>%
dplyr::group_by(!!d_id) %>%
dplyr::summarize(sum_pa= sum(f_p * f_c))
x <- x %>%
dplyr::left_join(sum_pa,
by = rlang::as_name(d_id))
f_t <- (f_p * f_c) / dplyr::pull(x, sum_pa)
x %>%
dplyr::mutate(V_ij = !!opp * !!f_t)
}
#defining the spatial availability function
sp_avail <- function(x, o_id, d_id, pop, opp, r, f, alpha = 1){
o_id <- rlang::enquo(o_id)
d_id <- rlang::enquo(d_id)
pop <- rlang::enquo(pop)
opp <- rlang::enquo(opp)
r <- rlang::enquo(r)
f <- rlang::enquo(f)
sum_pop <- x %>%
dplyr::distinct(!!o_id,
.keep_all = TRUE) %>%
dplyr::mutate(sum_pop = !!r*(!!pop)^alpha) %>%
dplyr::pull(sum_pop) %>%
sum()
f_p <- dplyr::pull(x, !!r) * dplyr::pull(x, !!pop)^alpha / sum_pop
sum_impedance <- x %>%
dplyr::group_by(!!d_id) %>%
dplyr::summarize(sum_impedance = sum(!!f))
x <- x %>%
dplyr::left_join(sum_impedance,
by = rlang::as_name(d_id))
f_c <- dplyr::pull(x, !!f) / x$sum_impedance
x$f_c <- f_c
x$f_p <- f_p
sum_pa <- x %>%
dplyr::group_by(!!d_id) %>%
dplyr::summarize(sum_pa= sum(f_p * f_c))
x <- x %>%
dplyr::left_join(sum_pa,
by = rlang::as_name(d_id))
f_t <- (f_p * f_c) / dplyr::pull(x, sum_pa)
x %>%
dplyr::mutate(V_ij = !!opp * !!f_t)
}
V_ij <- od_tt %>%
mutate(r = 1) %>%
sp_avail(o_id = o_id,
d_id = d_id,
pop = pop,
opp = opp,
r = r,
f = f,
alpha = 1.0) #1.54
V_ij
V_i <- V_ij |>
group_by(o_id) |>
summarize(V_i = sum(V_ij),
.groups = "drop")
V_i
(V_i$V_i - c(50000, 150000, 10000))/c(50000, 150000, 10000) * 100
sum(V_i$V_i)
sum(V_ij$opp)
sum(V_i$V_i)
View(V_ij)
V_ij %>%
group_by(d_id) %>%
summarize(opp = first(opp),
.groups = "drop")
V_ij %>%
group_by(d_id) %>%
summarize(opp = first(opp),
.groups = "drop") %>% sum()
V_ij |>
group_by(d_id) |>
summarize(opp = first(opp),
.groups = "drop") |> sum()
V_ij %>%
group_by(d_id) |>
summarize(opp = first(opp),
.groups = "drop") %>% as.data.frame() %>% sum()
V_ij %>%
group_by(d_id) |>
summarize(opp = first(opp),
.groups = "drop")
V_ij %>%
group_by(d_id) |>
summarize(opp = first(opp))
V_ij %>%
group_by(d_id) %>%
summarize(opp = first(opp))
V_ij %>%
group_by(d_id) |>
summarize(opp = first(opp),
.groups = "drop")
V_ij %>%
group_by(d_id) %>%
summarize(opp = first(opp)) %>% pull(opp)
V_ij %>%
group_by(d_id) %>%
summarize(opp = first(opp)) %>% pull(opp) %>% sum()
V_ij %>%
group_by(d_id) %>%
summarize(opp = first(opp)) %>% pull(opp) %>% sum()
sum(V_i$V_i)
V_j <- V_ij |>
group_by(d_id) |>
summarize(V_j = sum(V_ij),
.groups = "drop")
V_j
sum(V_j$V_j)
V_ij |>
pull(V_ij) |>
sum()
V_ij |>
group_by(o_id) |>
summarize(V_i = sum(V_ij),
.groups = "drop")
V_i
V_ij |>
group_by(o_id) |>
summarize(V_i = sum(V_ij),
.groups = "drop") |>
mutate(v_i = V_i / c(50000, 150000, 10000)) |>
pull(v_i)
V_ij |>
group_by(o_id) |>
summarize(V_i = sum(V_ij),
.groups = "drop") |>
mutate(v_i = V_i / c(50000, 150000, 10000))
V_ij |>
group_by(o_id) |>
summarize(V_i = sum(V_ij),
.groups = "drop") |>
mutate(v_i = V_i / c(50000, 150000, 10000))
library(TTS2016R)
library(dplyr)
library(fitdistrplus)
library(ggplot2)
library(kableExtra)
library(patchwork)
library(sf)
library(scales)
library(stats)
library(ggspatial)
library(shadowtext)
library(tmap)
# library(ggpmisc)
# library(ggrepel)
# library(cowplot)
# library(spdep)
# library(RColorBrewer)
# library(extrafont)
# font_import()
# loadfonts(device = "win")
options(scipen = 999)
library(TTS2016R)
library(dplyr)
library(fitdistrplus)
library(ggplot2)
library(kableExtra)
library(patchwork)
library(sf)
library(scales)
library(stats)
library(ggspatial)
library(shadowtext)
library(tmap)
# library(ggpmisc)
# library(ggrepel)
# library(cowplot)
# library(spdep)
# library(RColorBrewer)
# library(extrafont)
# font_import()
# loadfonts(device = "win")
options(scipen = 999)
# grouping the planning boundaries/municipalities so they make up the 20 regions in the TTS 2016. Note: st_buffer is used as there are small existing gaps between some boundaries. st_buffer of 10 m is enough to widen all boundaries and complete the st_union without issue.
group_ggh_pd_poly <- TTS2016R::ggh_pd %>% st_buffer(10) %>% group_by(REGION) %>%
summarize(REGION_name = first(REGION_name),
geometry = st_union((geometry)))
# creating an object of centroids for each region - this will be used to label polygons on the map
group_ggh_pd <- sf::st_centroid(group_ggh_pd_poly)
points <- sf::st_coordinates(group_ggh_pd) %>% data.frame()
group_ggh_pd <- cbind(group_ggh_pd, points)
## manually readjusting the X and Y coordinate of "County of Peterborough" and "Brant" as they overlap some cities
group_ggh_pd[group_ggh_pd$REGION_name=="Brant", "X"] <- 544000.0
group_ggh_pd[group_ggh_pd$REGION_name=="Brant", "Y"] <- 4767466
group_ggh_pd[group_ggh_pd$REGION_name=="Peterborough County", "Y"] <- 4921000
knitr::include_graphics("images/TTS16-survey-area.png")
#forming a complete descriptive statistic table
Statistics <- data.frame("Statistics" = c("Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max.", "NA's"))
Trips <- data.frame("OD_Trips" = c(summary(od$Persons)[[1]] %>% round(),
summary(od$Persons)[[2]] %>% round(),
summary(od$Persons)[[3]] %>% round(),
summary(od$Persons)[[4]] %>% round(),
summary(od$Persons)[[5]] %>% round(),
summary(od$Persons)[[6]]%>% round(),
NA))
