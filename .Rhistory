#main plot + adding the inset map.
mplot_SA_TTS <- ggdraw(mplot_SA_TTS) +
draw_plot({mplot_SA_TTS + coord_sf(xlim = st_coordinates(bbox_new)[c(1,2),1],
ylim = st_coordinates(bbox_new)[c(2,3),2],
expand = FALSE) +
theme(legend.position = "none")},
x = 0.57, y = 0.01,  # The distance along a (0,1) x-axis (and y axis) to draw the left edge (the bottom edge) of the plot
width = 0.46, height = 0.46) # The width and height of the plot expressed as proportion of the entire ggdraw object
mplot_access_TTS / mplot_SA_TTS
benchmark_TO_V_i_workers <- TO_taz_acc %>% st_drop_geometry() %>% summarise(avg_VO = sum(TO_V_i, na.rm=TRUE)/sum(workers, na.rm=TRUE)) %>% as.numeric()
mplot_SApW_TTS <- ggplot() +
geom_sf(data = TO_taz_acc, aes(fill= TO_V_i/workers), color = NA) + #data
scale_fill_gradient2(low = "deepskyblue4",
mid = "ghostwhite",
high = "red", #legend scale bar
name = "Spatially Availability \n per Worker (v_i)",
limits = c(0, max(TO_taz_acc$TO_V_i/TO_taz_acc$workers)),
midpoint= benchmark_TO_V_i_workers, #average V_i per capita
na.value = "gray90") +
geom_sf(data = toronto_muni_bound, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
geom_rect(data = data.frame(xmin = bbox_new1$xmin, ymin = bbox_new1$ymin, # rectangle on main plot marking inset location
xmax = bbox_new1$xmax, ymax = bbox_new1$ymax),
aes(xmin = bbox_new1$xmin, ymin = bbox_new1$ymin,
xmax = bbox_new1$xmax, ymax = bbox_new1$ymax),
fill = NA, colour = "dimgrey", size = 1) +
theme_void() +
theme(legend.position = c(1.15, 0.75),
plot.margin = margin(t = 0, r = 0, b = 0, l = -80))# positing legend and clipping out white space
#main plot + adding the inset map.
mplot_SApW_TTS <- ggdraw(mplot_SApW_TTS) +
draw_plot({mplot_SApW_TTS + coord_sf(xlim = st_coordinates(bbox_new)[c(1,2),1],
ylim = st_coordinates(bbox_new)[c(2,3),2],
expand = FALSE) +
theme(legend.position = "none")},
x = 0.57, y = 0.00,  # The distance along a (0,1) x-axis (and y axis) to draw the left edge (the bottom edge) of the plot
width = 0.46, height = 0.46) # The width and height of the plot expressed as proportion of the entire ggdraw object
mplot_SApW_TTS
#calculate spatial availability
GGH_od_ft <- od_ft %>%
mutate(catch = 1) %>%
mutate(GGH_V_ij = sp_avail(.,
o_id = Origin,
d_id = Destination,
pop = workers,
opp = jobs,
r = catch,
f = f))
#verify that the sum of all jobs is consistent with the number of jobs
sum(GGH_od_ft$GGH_V_ij, na.rm=T)
sum_jobs <- GGH_od_ft %>% group_by(Destination) %>% summarise(jobs = mean(jobs))
sum(sum_jobs$jobs, na.rm = T)
#aggregating spatial availability
GGH_availability <- GGH_od_ft %>%
group_by(Origin) %>%
summarize(GGH_V_i = sum(GGH_V_ij),
GGH_avgtt_i = mean(travel_time),
GGH_avg_f_i = mean(f))
#Merge TO availability calculation to the TAZ sf object created for accessibility above:
GGH_taz_acc <- GGH_taz_acc %>% merge(GGH_availability, by.x=c("GTA06"), by.y=c("Origin"), all.x=T)
## accessibility
#creating the main plot
mplot_access_TTS_GGH <- ggplot() +
geom_sf(data = GGH_taz_acc, aes(fill= GGH_A_i), color = NA) + #data
scale_fill_distiller(palette = "Spectral", #legend scale bar
name = "Accessibility \n(A_i)",
na.value = "grey90") +
geom_sf(data = toronto_muni_bound, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
theme_void() +
theme(legend.position = c(1.15, 0.75),
plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space
## spatial availability
mplot_SA_TTS_GGH <- ggplot() +
geom_sf(data = GGH_taz_acc, aes(fill= GGH_V_i), color = NA) + #data
scale_fill_distiller(palette = "Spectral", #legend scale bar
name = "Spatially Availability \n(V_i)",
na.value = "grey90") +
geom_sf(data = toronto_muni_bound, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
theme_void() +
theme(legend.position = c(1.15, 0.75),
plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space
mplot_access_TTS_GGH / mplot_SA_TTS_GGH
benchmark_GGH_V_i_workers <- GGH_taz_acc %>% st_drop_geometry() %>% summarise(avg_VO = sum(GGH_V_i, na.rm = TRUE)/sum(workers, na.rm = TRUE)) %>% as.numeric()
mplot_SApW_TTS_GGH <- ggplot() +
geom_sf(data = GGH_taz_acc, aes(fill= GGH_V_i/workers), color = NA) + #data
scale_fill_gradient2(low = "deepskyblue4",
mid = "ghostwhite",
high = "red", #legend scale bar
name = "Spatially Availability \n per Worker (v_i)",
limits = c(0, max(GGH_taz_acc$GGH_V_i/GGH_taz_acc$workers)),
midpoint= benchmark_GGH_V_i_workers, #average V_i per capita
na.value = "grey90") +
geom_sf(data = toronto_muni_bound, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
theme_void() +
theme(legend.position = c(1.15, 0.75),
plot.margin = margin(t = 0, r = 0, b = 0, l = -80))# positing legend and clipping out white space
mplot_SApW_TTS_GGH
#here we index (re-scale) the accessibility and spatial availability measures and split up the objects into POSITIVE change (i.e. when SA is higher than accessibility) and NEGATIVE change (i.e. when SA is lower than accessibility)
TO_indexed_measures_ALL <- TO_taz_acc %>%
mutate(A_indexed = TO_A_i/(max(TO_A_i, na.rm = TRUE))*100,
V_indexed = TO_V_i/(max(TO_V_i, na.rm = TRUE))*100,
A_V_indexed_change = (V_indexed - A_indexed)/A_indexed,
TO_avg_f_i)
TO_indexed_measures_pos <- TO_indexed_measures_ALL %>%
filter(A_V_indexed_change >= 0 )
TO_indexed_measures_neg <- TO_indexed_measures_ALL %>%
filter(A_V_indexed_change < 0 )#& (
# A_V_indexed_change_rank == 1|
# A_V_indexed_change_rank == 2 |
# A_V_indexed_change_rank == 3 |
#  A_V_indexed_change_rank == 4 ))
boxplot(TO_indexed_measures_pos$A_V_indexed_change, horizontal=TRUE)
boxplot(TO_indexed_measures_neg$A_V_indexed_change, horizontal=TRUE)
boxplot(TO_indexed_measures_ALL$A_V_indexed_change, horizontal=TRUE)
# as a comment.. Moran I's test is not robust to outliers- if we remove all of Quantile 5 (i.e. ~ -70%-0%) from the negative change data set this will remove all the outliers. For the time being though, I am not doing that and am just proceeding.
taz_nb <- poly2nb(TO_indexed_measures_neg, queen = TRUE)
taz_w <- nb2listw(taz_nb, zero.policy = TRUE)
moran.test(TO_indexed_measures_neg$A_V_indexed_change, taz_w, zero.policy = TRUE, na.action=na.exclude)
local_i <- localmoran(TO_indexed_measures_neg$A_V_indexed_change,
taz_w,
alternative = "two.sided",
zero.policy = TRUE, na.action=na.exclude) %>%
data.frame() %>%
rename(p_val = Pr.z....E.Ii..) %>%
mutate(significance = ifelse(p_val <= 0.10, "sig", "n.s."),
significance = factor(significance,
levels = c("n.s.", "sig")))
summary(local_i)
TO_indexed_measures_neg$significance <- local_i$significance
#graphinh histogram to create good breaks for plot
hist(TO_indexed_measures_neg$A_V_indexed_change, breaks = 4)
plot_morani_Toronto <- ggplot() +
geom_sf(data = TO_indexed_measures_pos, fill = "#999999") +
geom_sf(data = TO_indexed_measures_neg,
aes(fill = cut(A_V_indexed_change,quantile(A_V_indexed_change, probs = seq(0, 1, 0.20))),
alpha = significance),
color = NA,
size = 0.01) +
geom_sf(data = toronto_muni_bound, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
scale_fill_manual(values = brewer.pal(5,"Spectral"),
name = "Difference Between \n Job Access Measures",
labels = c("-99% to -95% (Q1)",
"-95% to -89% (Q2)",
"-89% to -81% (Q3)",
"-81% to -70% (Q4)",
"-70% to -3% (Q5)",
"Positive difference")) +
scale_alpha_manual(values = c("n.s." = 0.5,
"sig" = 1)) +
guides(alpha = "none",
fill = guide_legend(title.position = "top")) +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
theme_void() +
theme(legend.position = c(1.15, 0.75),
plot.margin = margin(t = 0, r = 0, b = 0, l = -80))# positing legend and clipping out white space
#main plot + adding the inset map.
plot_morani_Toronto <- ggdraw(plot_morani_Toronto) +
draw_plot({plot_morani_Toronto + coord_sf(xlim = st_coordinates(bbox_new)[c(1,2),1],
ylim = st_coordinates(bbox_new)[c(2,3),2],
expand = FALSE) +
theme(legend.position = "none")},
x = 0.57, y = 0.00,  # The distance along a (0,1) x-axis (and y axis) to draw the left edge (the bottom edge) of the plot
width = 0.46, height = 0.46) # The width and height of the plot expressed as proportion of the entire ggdraw object
plot_morani_Toronto
t <- TO_indexed_measures_neg %>% st_drop_geometry()
cor(t[, c('workers', 'jobs', "TO_A_i", "TO_V_i", "trips_i", "A_indexed", "V_indexed", "A_V_indexed_change", "TO_avg_f_i")])
# not included.. this is the density distribution of the scaled values. It dones't give us any thing new.
x <- data.frame(TO_A = TO_indexed_measures_ALL$A_indexed, TO_V = TO_indexed_measures_ALL$V_indexed)
library(reshape2)
data <- melt(x)
ggplot(data,aes(x=value, fill=variable)) + geom_density(alpha=0.25)
#here we index (re-scale) the accessibility and spatial availability measures and split up the objects into POSITIVE change (i.e. when SA is higher than accessibility) and NEGATIVE change (i.e. when SA is lower than accessibility)
GGH_indexed_measures_ALL <- GGH_taz_acc %>%
mutate(A_indexed = GGH_A_i/(max(GGH_A_i, na.rm = TRUE))*100,
V_indexed = GGH_V_i/(max(GGH_V_i, na.rm = TRUE))*100,
A_V_indexed_change = (V_indexed - A_indexed)/A_indexed,
GGH_avg_f_i)
GGH_indexed_measures_pos <- GGH_indexed_measures_ALL %>%
filter(A_V_indexed_change >= 0)
GGH_indexed_measures_neg <- GGH_indexed_measures_ALL %>%
filter(A_V_indexed_change < 0 )
boxplot(GGH_indexed_measures_ALL$A_V_indexed_change, horizontal=TRUE)
# as a comment.. Moran I's test is not robust to outliers- if we remove all of Quantile 5 (i.e. ~ -70%-0%) from the negative change data set and Quantile 5 from the positive set (i.e. ~ ) (this will remove all the outliers. For the time being though, I am not doing that and am just proceeding.
taz_nb <- poly2nb(GGH_indexed_measures_ALL, queen = TRUE)
taz_w <- nb2listw(taz_nb, zero.policy = TRUE)
moran.test(GGH_indexed_measures_ALL$A_V_indexed_change, taz_w, zero.policy = TRUE, na.action=na.exclude)
local_i <- localmoran(GGH_indexed_measures_ALL$A_V_indexed_change,
taz_w,
alternative = "two.sided",
zero.policy = TRUE, na.action=na.exclude) %>%
data.frame() %>%
rename(p_val = Pr.z....E.Ii..) %>%
mutate(significance = ifelse(p_val <= 0.10, "sig", "n.s."),
significance = factor(significance,
levels = c("n.s.", "sig")))
#many of the underestiamted TAZs are outliers.
summary(local_i)
#GGH_indexed_measures_neg$significance <- local_i$significance
GGH_indexed_measures_pos <- GGH_indexed_measures_ALL %>%
filter(A_V_indexed_change >= 0)
GGH_indexed_measures_neg <- GGH_indexed_measures_ALL %>%
filter(A_V_indexed_change < 0 )
GGH_indexed_change_neg <- ggplot() + ggtitle("Overestimation") +
geom_sf(data = GGH_indexed_measures_pos, fill = "#999999", size = 0.01) +
geom_sf(data = GGH_indexed_measures_neg,
aes(fill = cut(A_V_indexed_change,quantile(A_V_indexed_change, probs = seq(0, 1, 0.20)))),
color = NA,
size = 0.01) +
geom_sf(data = toronto_muni_bound, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
scale_fill_manual(values = brewer.pal(5,"Spectral"),
name = " ",
labels = c("-99% to -93% (Q1)",
"-93% to -83% (Q2)",
"-83% to -70% (Q3)",
"-70% to -47% (Q4)",
"-47% to -0.1% (Q5)",
"Positive difference")) +
guides(alpha = "none",
fill = guide_legend(title.position = "top")) +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
theme_void()
#positive
GGH_indexed_change_pos <- ggplot() + ggtitle("Underestimation") +
geom_sf(data = GGH_indexed_measures_neg, fill = "#999999", size = 0.01) +
geom_sf(data = GGH_indexed_measures_pos,
aes(fill = cut(A_V_indexed_change,quantile(A_V_indexed_change, probs = seq(0, 1, 0.20)))),
color = NA,
size = 0.01) +
geom_sf(data = toronto_muni_bound, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
scale_fill_manual(values = rev(brewer.pal(5,"Spectral")),
name = " ",
labels = c("0% to 22% (Q1)",
"22% to 49% (Q2)",
"49% to 91% (Q3)",
"91% to 176% (Q4)",
"176% + (Q5)",
"Negative difference")) +
guides(alpha = "none",
fill = guide_legend(title.position = "top")) +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
guides(fill = guide_legend(reverse = FALSE)) +
theme_void() +
theme(legend.position = "none",
plot.title = element_text(hjust = 0.5))
GGH_indexed_change_pos / GGH_indexed_change_neg  & theme(legend.position = "right")
t <- GGH_indexed_measures_pos %>% st_drop_geometry()
cor(t[, c('workers', 'jobs', "GGH_A_i", "GGH_V_i", "trips_i", "A_indexed", "V_indexed", "A_V_indexed_change", "GGH_avgtt_i")])
# Create catchments for visualization:
catchment_1 <- toy_sim_zones_access %>% filter(id == "Employment Center 1" |
id == "Population 1" |
id == "Population 2") %>%
st_union %>%
st_convex_hull()  %>%
st_buffer(480)
catchment_2 <- toy_sim_zones_access %>% filter(id == "Employment Center 2" |
id == "Population 3" |
id == "Population 4" |
id == "Population 5" |
id == "Population 7" |
id == "Population 8") %>%
st_union %>%
st_convex_hull()  %>%
st_buffer(480)
catchment_3 <- toy_sim_zones_access %>% filter(id == "Employment Center 3" |
id == "Population 5" |
id == "Population 6" |
id == "Population 8" |
id == "Population 9") %>%
st_union %>%
st_convex_hull()  %>%
st_buffer(480)
#Calculate the proportional allocation of opportunities but now with catchment constraint (referred to as $V_ij_r$):
toy_od_table <- toy_od_table %>%
mutate(V_ij_r = sp_avail(.,
o_id = Origin,
d_id = Destination,
pop = Population,
opp = Jobs,
r = catchments,
f = f))
#Verify that the sum of all jobs allocated is consistent with the total number of jobs:
sum(toy_od_table$V_ij_r)
sum_jobs <- toy_od_table %>% group_by(Destination) %>% summarise(Jobs = mean(Jobs))
sum(sum_jobs$Jobs, na.rm = T)
#Repeat the availability calculation:
availability <- toy_od_table %>%
group_by(Origin) %>%
summarize(V_i_r = sum(V_ij_r))
#availability
#Join the availability to the toy_sim_zones_access:
toy_sim_zones_access <- toy_sim_zones_access %>%
left_join(availability,
by = c("id" = "Origin"))
ggplot() +
geom_sf(data = catchment_1,
fill = "orange",
alpha = 0.05) +
geom_sf(data = catchment_1,
color = "orange",
fill = NA) +
geom_sf(data = catchment_2,
fill = "blue",
alpha = 0.05) +
geom_sf(data = catchment_2,
color = "blue",
fill = NA) +
geom_sf(data = catchment_3,
fill = "red",
alpha = 0.05) +
geom_sf(data = catchment_3,
color = "red",
fill = NA) +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "population"),
aes(fill = V_i_r, size = V_i_r, shape = type)) +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "jobs"),
aes(shape = type),
size = 7, fill = "black") +
geom_sf_text(data = toy_sim_zones_access , aes(label = id_short),
size = 3, nudge_y = -400) +
scale_shape_manual(values = c('population' = 24, 'jobs' = 21), name = "Location Type", labels=c("Population", "Jobs"),
guide = guide_legend(order = 2)) +
scale_size_continuous(range = c(3,7), name = "Spatial Availability \n(V_i_r)", guide = "none") +
scale_fill_distiller(palette = "Greens", direction = 1, name = "Spatial Availability \n(V_i_r)",
limits = c(0, max(toy_sim_zones_access$V_i_r, na.rm = T)),
guide = guide_colorbar(order = 1)) +
theme(legend.position = "right", axis.text = element_blank(), axis.title = element_blank(),
panel.grid = element_blank(),
panel.background = element_rect(size = 1.5,
color = "grey",
fill = "gray95"))
toy_sim_zones_access <- toy_sim_zones_access %>%
mutate(v_i_r = V_i_r/number)
toy_od_table <- toy_od_table %>%
mutate(catch = 1) %>% # No catchment restrictions, all members of the population are eligible for the opportunities
mutate(V_ij = sp_avail(.,
o_id = Origin,
d_id = Destination,
pop = Population,
opp = Jobs,
r = catch,
f = f))
# After calculating that spatial availability, we can verify that the sum of all available jobs  is consistent with the total number of jobs in the region:
sum(toy_od_table$V_ij)
toy_sim_zones %>%
filter(type == "jobs") %>%
pull(number) %>%
sum()
# The total number of jobs is preserved, as desired.
# Next we aggregate the jobs spatially available by origin-destination pair to obtain $V_i$:
availability <- toy_od_table %>%
group_by(Origin) %>%
summarize(V_i = sum(V_ij))
availability
# To visualize the outcome we proceed to join the availability to the zones in the example:
toy_sim_zones_access <- toy_sim_zones_access %>%
left_join(availability,
by = c("id" = "Origin"))
# per person availability
toy_sim_zones_access <- toy_sim_zones_access %>%
mutate(v_i = V_i/number)
plot_toy_SA_catch <- ggplot() +
geom_sf(data = catchment_1,
color = "orange",
fill = "orange",
alpha = 0.02) +
geom_sf(data = catchment_2,
color = "blue",
fill = "blue",
alpha = 0.02) +
geom_sf(data = catchment_3,
color = "red",
fill = "red",
alpha = 0.02) +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "population"),
aes(fill = toy_sim_zones_access$v_i_r, size = toy_sim_zones_access$v_i_r, shape = type)) +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "jobs"),
aes(shape = type),
size = 7, fill = "black") +
geom_sf_text(data = toy_sim_zones_access , aes(label = id_short),
size = 3, nudge_y = -400) +
scale_shape_manual(values = c('population' = 24, 'jobs' = 21), name = "Location Type", labels=c("Population", "Jobs"),
guide = guide_legend(order=2)) +
scale_size_continuous( range = c(3,7), name = "Spatial Availability \nper Capita (v_i_r)", guide = "none") +
scale_fill_gradient2(low = "goldenrod1",
mid = "white",
high = "darkgreen",
name = "Spatial Availability \nper Capita (v_i_r)",
midpoint = mean(toy_sim_zones_access$v_i_r, na.rm = T),
limits = c(0, max(toy_sim_zones_access$v_i_r, na.rm = T)),
guide = guide_colorbar(order = 1)) +
theme(legend.position = "right", axis.text = element_blank(), axis.title = element_blank(),
panel.grid = element_blank(),
panel.background = element_rect(size = 1.5,
color = "grey",
fill = "gray95"))
plot_toy_SA <- ggplot() +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "population"),
aes(fill = v_i, size = v_i, shape = type)) +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "jobs"),
aes(shape = type),
size = 7, fill = "black") +
geom_sf_text(data = toy_sim_zones_access , aes(label = id_short),
size = 3, nudge_y = -400) +
scale_shape_manual(values = c('population' = 24, 'jobs' = 21), name = "Location Type", labels=c("Population", "Jobs"),
guide = guide_legend(order = 2)) +
scale_size_continuous( range = c(3,7), name = "Spatial Availability \nper Capita (v_i)", guide = "none") +
scale_fill_gradient2(name = "Spatial Availability \nper Capita (v_i)",
low = "goldenrod1",
mid = "white",
high = "darkgreen",
midpoint = mean(toy_sim_zones_access$v_i, na.rm = T),
limits = c(0, max(toy_sim_zones_access$v_i, na.rm = T)),
guide = guide_colorbar(order = 1)) +
theme(legend.position = "right", axis.text = element_blank(), axis.title = element_blank(),
panel.grid = element_blank(),
panel.background = element_rect(size = 1.5,
color = "grey",
fill = "gray95"))
plot_toy_SA_catch / plot_toy_SA
View(toy_sim_zones_access)
toy_sim_zones_access$v_i_r
mean(toy_sim_zones_access$v_i_r)
mean(toy_sim_zones_access$v_i_r, na.rm=T)
colMeans(toy_sim_zones_access$v_i_r, na.rm = TRUE)
colMeans(toy_sim_zones_access$v_i_r)
colMeans(toy_sim_zones_access)
colMeans(toy_sim_zones_access, v_i_r)
colMeans(toy_sim_zones_access)
colMeans(toy_sim_zones_access$v_i_r, na.rm = TRUE)
mean(toy_sim_zones_access$v_i_r, na.rm = TRUE)
round(mean(toy_sim_zones_access$v_i, na.rm = TRUE),3)
round(mean(toy_sim_zones_access$v_i_r, na.rm = TRUE),3)
round(mean(toy_sim_zones_access$v_i_r, na.rm = TRUE),3)
