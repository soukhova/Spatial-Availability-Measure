## spatial availability
mplot_SA_TTS_GGH <- ggplot() +
geom_sf(data = GGH_taz_acc, aes(fill= GGH_V_i), color = NA) + #data
scale_fill_distiller(palette = "Spectral", #legend scale bar
name = "Spatially Availability \n(V_i)",
na.value = "grey80") +
geom_sf(data = toronto_muni_bound, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
geom_sf(data = hamilton_cma, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
theme_void() +
theme(legend.position = c(1.15, 0.75),
plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space
mplot_access_TTS_GGH / mplot_SA_TTS_GGH
benchmark_GGH_V_i_workers <- GGH_taz_acc %>% st_drop_geometry() %>% summarise(avg_VO = sum(GGH_V_i)/sum(workers)) %>% as.numeric()
mplot_SApW_TTS_GGH <- ggplot() +
geom_sf(data = GGH_taz_acc, aes(fill= GGH_V_i/workers), color = NA) + #data
scale_fill_gradient2(low = "deepskyblue4",
mid = "ghostwhite",
high = "red", #legend scale bar
name = "Spatially Availability \n per Worker (v_i)",
limits = c(0, max(GGH_taz_acc$GGH_V_i/GGH_taz_acc$workers)),
midpoint= benchmark_GGH_V_i_workers, #average V_i per capita
) +
geom_sf(data = toronto_muni_bound, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
geom_sf(data = hamilton_cma, # border for Hamilton
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
theme_void() +
theme(legend.position = c(1.15, 0.75),
plot.margin = margin(t = 0, r = 0, b = 0, l = -80))# positing legend and clipping out white space
mplot_SApW_TTS_GGH
indexed_measures_pos <- TO_taz_acc %>%
mutate(A_indexed = TO_A_i/(max(TO_A_i))*100,
V_indexed = TO_V_i/(max(TO_V_i))*100,
A_V_indexed_change = (V_indexed - A_indexed)/A_indexed,
TO_avg_f_i) %>%
filter(A_V_indexed_change >= 0) %>%
mutate(A_V_indexed_change_rank = ntile(A_V_indexed_change,5))
indexed_measures_neg <- TO_taz_acc %>%
mutate(A_indexed = TO_A_i/(max(TO_A_i))*100,
V_indexed = TO_V_i/(max(TO_V_i))*100,
A_V_indexed_change = (V_indexed - A_indexed)/A_indexed,
TO_avg_f_i) %>%
filter(A_V_indexed_change < 0) %>%
mutate(A_V_indexed_change_rank = ntile(A_V_indexed_change,5))
indexed_change <- ggplot() +
geom_sf(data = indexed_measures_neg,
aes(fill = A_V_indexed_change_rank),  color = NA) +
scale_fill_distiller(palette = "Spectral", direction = 1, name = "Quantile Ranks
of the % Difference
Between Job Access
Measures")+
geom_sf(data = toronto_muni_bound, colour="black", fill=NA,  color = NA) +
geom_sf(data = indexed_measures_pos, fill = "#999999") +
geom_sf(data = toronto_muni_bound, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
guides(fill = guide_legend(reverse = FALSE)) +
theme_void() +
theme(legend.position = "right")
## I was attempting to insert a table on the plot which shows the ranges of the quantiles... thoughts? Ex. Quantile 1 represents a -100% to -95% difference, Quantile 2 represents.. etc.
quantile_ranges <- indexed_measures_neg %>% group_by(A_V_indexed_change_rank) %>% st_drop_geometry() %>%
summarise(low = percent(min(A_V_indexed_change)),
high = percent(max(A_V_indexed_change))) %>% plyr::rename(., c("A_V_indexed_change_rank" = "Quantile",
"low" = "Lower",
"high" = "Upper"))
# indexed_change +
#   annotate(geom = "table",
#             x = Inf, y = - Inf,
#            label = list(quantile_ranges))
indexed_change
t <- indexed_measures_neg %>% st_drop_geometry()
cor(t[, c('workers', 'jobs', "TO_A_i", "TO_V_i", "trips_i", "A_indexed", "V_indexed", "A_V_indexed_change", "TO_avg_f_i")])
plot_workers <- ggplot() +
geom_sf(data = indexed_measures_neg, aes(fill= workers), color = NA) + #data
scale_fill_distiller(palette = "Spectral", #legend scale bar
name = "# of Workers",
limits = c(0, max(indexed_measures_neg$workers)),
na.value = "grey80") +
geom_sf(data = toronto_muni_bound, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
geom_rect(data = data.frame(xmin = bbox_new1$xmin, ymin = bbox_new1$ymin, # rectangle on main plot marking inset location
xmax = bbox_new1$xmax, ymax = bbox_new1$ymax),
aes(xmin = bbox_new1$xmin, ymin = bbox_new1$ymin,
xmax = bbox_new1$xmax, ymax = bbox_new1$ymax),
fill = NA, colour = "dimgrey", size = 1) +
theme_void() +
theme(legend.position = c(1.15, 0.75),
plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space
#main plot + adding the inset map.
plot_workers <- ggdraw( plot_workers) +
draw_plot({ plot_workers + coord_sf(xlim = st_coordinates(bbox_new)[c(1,2),1],
ylim = st_coordinates(bbox_new)[c(2,3),2],
expand = FALSE) +
theme(legend.position = "none")},
x = 0.57, y = 0.01,  # The distance along a (0,1) x-axis (and y axis) to draw the left edge (the bottom edge) of the plot
width = 0.46, height = 0.46) # The width and height of the plot expressed as proportion of the entire ggdraw object
plot_imp <- ggplot() +
geom_sf(data = indexed_measures_neg, aes(fill= TO_avg_f_i), color = NA) + #data
scale_fill_distiller(palette = "Spectral", #legend scale bar
name = "Impedence function value",
limits = c(0, max(indexed_measures_neg$TO_avg_f_i)),
na.value = "grey80") +
geom_sf(data = toronto_muni_bound, # border for Toronto
colour=alpha("dimgrey",1),
size = 0.5, fill=NA,
show.legend = "polygon") +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
geom_rect(data = data.frame(xmin = bbox_new1$xmin, ymin = bbox_new1$ymin, # rectangle on main plot marking inset location
xmax = bbox_new1$xmax, ymax = bbox_new1$ymax),
aes(xmin = bbox_new1$xmin, ymin = bbox_new1$ymin,
xmax = bbox_new1$xmax, ymax = bbox_new1$ymax),
fill = NA, colour = "dimgrey", size = 1) +
theme_void() +
theme(legend.position = c(1.15, 0.75),
plot.margin = margin(t = 0, r = 0, b = 0, l = -80)) # positing legend and clipping out white space
#main plot + adding the inset map.
plot_imp <- ggdraw( plot_imp) +
draw_plot({ plot_imp + coord_sf(xlim = st_coordinates(bbox_new)[c(1,2),1],
ylim = st_coordinates(bbox_new)[c(2,3),2],
expand = FALSE) +
theme(legend.position = "none")},
x = 0.57, y = 0.01,  # The distance along a (0,1) x-axis (and y axis) to draw the left edge (the bottom edge) of the plot
width = 0.46, height = 0.46) # The width and height of the plot expressed as proportion of the entire ggdraw object
plot_workers / plot_imp
GGH_indexed_measures_pos <- GGH_taz_acc %>%
mutate(A_indexed = GGH_A_i/(max(GGH_A_i))*100,
V_indexed = GGH_V_i/(max(GGH_V_i))*100,
A_V_indexed_change = (V_indexed - A_indexed)/A_indexed) %>%
filter(A_V_indexed_change >= 0) %>%
mutate(A_V_indexed_change_rank = ntile(A_V_indexed_change,5))
GGH_indexed_measures_neg <- GGH_taz_acc %>%
mutate(A_indexed = GGH_A_i/(max(GGH_A_i))*100,
V_indexed = GGH_V_i/(max(GGH_V_i))*100,
A_V_indexed_change = (V_indexed - A_indexed)/A_indexed) %>%
filter(A_V_indexed_change < 0) %>%
mutate(A_V_indexed_change_rank = ntile(A_V_indexed_change,5))
## Negative
GGH_indexed_change_neg <- ggplot() + ggtitle("Overestimation") +
geom_sf(data = GGH_indexed_measures_neg,
aes(fill = A_V_indexed_change_rank),  color = NA) +
scale_fill_distiller(palette = "Spectral", direction = 1,
name = "Quantile Ranks of the
% Difference Between
Job Access Measures")+
geom_sf(data = GGH_indexed_measures_pos, fill = "#999999") +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
guides(fill = guide_legend(reverse = FALSE),
title  ) +
theme_void() +
theme(legend.position = "none",
plot.title = element_text(hjust = 0.5))
## Positive
GGH_indexed_change_pos <- ggplot() + ggtitle("Underestimation") +
geom_sf(data = GGH_indexed_measures_pos,
aes(fill = A_V_indexed_change_rank),  color = NA) +
scale_fill_distiller(palette = "Spectral", direction = 1,
name = "Quantile Ranks of the
% Difference Between
Job Access Measures")+
geom_sf(data = GGH_indexed_measures_neg, fill = "#999999") +
annotation_north_arrow(location = "tl", # north arrow for both the main plot and inset
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot and inset
height = unit(0.15, "cm")) +
guides(fill = guide_legend(reverse = FALSE)) +
theme_void() +
theme(legend.position = "none",
plot.title = element_text(hjust = 0.5))
GGH_indexed_change_neg + GGH_indexed_change_pos & theme(legend.position = "bottom")
t <- GGH_indexed_measures_neg %>% st_drop_geometry()
cor(t[, c('workers', 'jobs', "GGH_A_i", "GGH_V_i", "trips_i", "A_indexed", "V_indexed", "A_V_indexed_change", "GGH_avgtt_i")])
toy_od_table <- toy_od_table %>%
mutate(catch = 1) %>% # No catchment restrictions, all members of the population are eligible for the opportunities
mutate(V_ij = sp_avail(.,
o_id = Origin,
d_id = Destination,
pop = Population,
opp = Jobs,
r = catch,
f = f))
# After calculating that spatial availability, we can verify that the sum of all available jobs  is consistent with the total number of jobs in the region:
sum(toy_od_table$V_ij)
toy_sim_zones %>%
filter(type == "jobs") %>%
pull(number) %>%
sum()
# The total number of jobs is preserved, as desired.
# Next we aggregate the jobs spatially available by origin-destination pair to obtain $V_i$:
availability <- toy_od_table %>%
group_by(Origin) %>%
summarize(V_i = sum(V_ij))
availability
# To visualize the outcome we proceed to join the availability to the zones in the example:
toy_sim_zones_access <- toy_sim_zones_access %>%
left_join(availability,
by = c("id" = "Origin"))
# per person availability
toy_sim_zones_access <- toy_sim_zones_access %>%
mutate(v_i = V_i/number)
ggplot() +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "population"),
aes(size = V_i, fill = V_i, shape = type)) +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "jobs"),
aes(shape = type),
size = 7, fill = "black") +
geom_sf_text(data = toy_sim_zones_access , aes(label = id_short),
size = 3, nudge_y = -400) +
scale_size_continuous(range = c(3,7), name = "Spatial Availability \n(V_i)", guide = "none") +
scale_fill_distiller(palette = "Greens", direction = 1, name = "Spatial Availability \n(V_i)",
limits = c(0, max(toy_sim_zones_access$V_i)),
guide = guide_colourbar(order = 1)) +
scale_shape_manual(values = c('population' = 24, 'jobs' = 21), name = "Location Type", labels=c("Population", "Jobs"),
guide = guide_legend(order = 2)) +
theme(legend.position = "right", axis.text = element_blank(), axis.title = element_blank(),
panel.grid = element_blank(),
panel.background = element_rect(size = 1.5,
color = "grey",
fill = "gray95"))
ggplot() +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "population"),
aes(fill = v_i, size = v_i, shape = type)) +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "jobs"),
aes(shape = type),
size = 7, fill = "black") +
geom_sf_text(data = toy_sim_zones_access , aes(label = id_short),
size = 3, nudge_y = -400) +
scale_shape_manual(values = c('population' = 24, 'jobs' = 21), name = "Location Type", labels=c("Population", "Jobs"),
guide = guide_legend(order = 2)) +
scale_size_continuous( range = c(3,7), name = "Spatial Availability \nper Capita (v_i)", guide = "none") +
scale_fill_gradient2(name = "Spatial Availability \nper Capita (v_i)",
low = "goldenrod1",
mid = "white",
high = "darkgreen",
midpoint = mean(toy_sim_zones_access$v_i, na.rm = T),
limits = c(0, max(toy_sim_zones_access$v_i)),
guide = guide_colorbar(order = 1)) +
theme(legend.position = "right", axis.text = element_blank(), axis.title = element_blank(),
panel.grid = element_blank(),
panel.background = element_rect(size = 1.5,
color = "grey",
fill = "gray95"))
# Create catchments for visualization:
catchment_1 <- toy_sim_zones_access %>% filter(id == "Employment Center 1" |
id == "Population 1" |
id == "Population 2") %>%
st_union %>%
st_convex_hull()  %>%
st_buffer(480)
catchment_2 <- toy_sim_zones_access %>% filter(id == "Employment Center 2" |
id == "Population 3" |
id == "Population 4" |
id == "Population 5" |
id == "Population 7" |
id == "Population 8") %>%
st_union %>%
st_convex_hull()  %>%
st_buffer(480)
catchment_3 <- toy_sim_zones_access %>% filter(id == "Employment Center 3" |
id == "Population 5" |
id == "Population 6" |
id == "Population 8" |
id == "Population 9") %>%
st_union %>%
st_convex_hull()  %>%
st_buffer(480)
#Calculate the proportional allocation of opportunities but now with catchment constraint (referred to as $V_ij_r$):
toy_od_table <- toy_od_table %>%
mutate(V_ij_r = sp_avail(.,
o_id = Origin,
d_id = Destination,
pop = Population,
opp = Jobs,
r = catchments,
f = f))
#Verify that the sum of all jobs allocated is consistent with the total number of jobs:
sum(toy_od_table$V_ij_r)
sum_jobs <- toy_od_table %>% group_by(Destination) %>% summarise(Jobs = mean(Jobs))
sum(sum_jobs$Jobs, na.rm = T)
#Repeat the availability calculation:
availability <- toy_od_table %>%
group_by(Origin) %>%
summarize(V_i_r = sum(V_ij_r))
#availability
#Join the availability to the toy_sim_zones_access:
toy_sim_zones_access <- toy_sim_zones_access %>%
left_join(availability,
by = c("id" = "Origin"))
ggplot() +
geom_sf(data = catchment_1,
fill = "orange",
alpha = 0.05) +
geom_sf(data = catchment_1,
color = "orange",
fill = NA) +
geom_sf(data = catchment_2,
fill = "blue",
alpha = 0.05) +
geom_sf(data = catchment_2,
color = "blue",
fill = NA) +
geom_sf(data = catchment_3,
fill = "red",
alpha = 0.05) +
geom_sf(data = catchment_3,
color = "red",
fill = NA) +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "population"),
aes(fill = V_i_r, size = V_i_r, shape = type)) +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "jobs"),
aes(shape = type),
size = 7, fill = "black") +
geom_sf_text(data = toy_sim_zones_access , aes(label = id_short),
size = 3, nudge_y = -400) +
scale_shape_manual(values = c('population' = 24, 'jobs' = 21), name = "Location Type", labels=c("Population", "Jobs"),
guide = guide_legend(order = 2)) +
scale_size_continuous(range = c(3,7), name = "Spatial Availability \n(V_i_r)", guide = "none") +
scale_fill_distiller(palette = "Greens", direction = 1, name = "Spatial Availability \n(V_i_r)",
limits = c(0, max(toy_sim_zones_access$V_i_r)),
guide = guide_colorbar(order = 1)) +
theme(legend.position = "right", axis.text = element_blank(), axis.title = element_blank(),
panel.grid = element_blank(),
panel.background = element_rect(size = 1.5,
color = "grey",
fill = "gray95"))
toy_sim_zones_access <- toy_sim_zones_access %>%
mutate(v_i_r = V_i_r/number)
ggplot() +
geom_sf(data = catchment_1,
color = "orange",
fill = "orange",
alpha = 0.02) +
geom_sf(data = catchment_2,
color = "blue",
fill = "blue",
alpha = 0.02) +
geom_sf(data = catchment_3,
color = "red",
fill = "red",
alpha = 0.02) +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "population"),
aes(fill = v_i_r, size = v_i_r, shape = type)) +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "jobs"),
aes(shape = type),
size = 7, fill = "black") +
geom_sf_text(data = toy_sim_zones_access , aes(label = id_short),
size = 3, nudge_y = -400) +
scale_shape_manual(values = c('population' = 24, 'jobs' = 21), name = "Location Type", labels=c("Population", "Jobs"),
guide = guide_legend(order=2)) +
scale_size_continuous( range = c(3,7), name = "Spatial Availability \nper Capita (v_i_r)", guide = "none") +
scale_fill_gradient2(low = "goldenrod1",
mid = "white",
high = "darkgreen",
name = "Spatial Availability \nper Capita (v_i_r)",
midpoint = mean(toy_sim_zones_access$v_i_r, na.rm=T),
limits = c(0, max(toy_sim_zones_access$v_i_r)),
guide = guide_colorbar(order = 1)) +
theme(legend.position = "right", axis.text = element_blank(), axis.title = element_blank(),
panel.grid = element_blank(),
panel.background = element_rect(size = 1.5,
color = "grey",
fill = "gray95"))
toy_od_table <- toy_od_table %>%
mutate(catch = 1) %>%
mutate(W_ji = sp_avail(.,
o_id = Destination,
d_id = Origin,
pop = Jobs,
opp = Population,
r = catch,
f = f))
#Verify that the sum of all population allocated is consistent with the total number of population:
sum(toy_od_table$W_ji)
toy_sim_zones %>%
filter(type == "population") %>%
pull(number) %>%
sum()
# The total population is preserved, as desired.
# Aggregate available workers by employment center:
availability <- toy_od_table %>%
group_by(Destination) %>%
summarize(W_j = sum(W_ji))
#availability
# Join the availability to the toy_sim_zones_access:
toy_sim_zones_access <- toy_sim_zones_access %>%
left_join(availability,
by = c("id" = "Destination"))
ggplot() +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "jobs"),
aes(fill = W_j, size = W_j, shape = type)) +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "population"),
aes(shape = type),
size = 6, fill = "black") +
geom_sf_text(data = toy_sim_zones_access , aes(label = id_short),
size = 3, nudge_y = -400) +
scale_shape_manual(values = c('population' = 24, 'jobs' = 21), name = "Location Type", labels=c("Population", "Jobs"),
guide = guide_legend(order = 2)) +
scale_size_continuous(range = c(4,9), name = "Spatial Availability \n(W_j)", guide = "none") +
scale_fill_distiller(palette = "Greens", direction = 1, name = "Spatial Availability \n(W_j)",
limits = c(0, max(toy_sim_zones_access$W_j)),
guide = guide_colourbar(order = 1)) +
theme(legend.position = "right", axis.text = element_blank(), axis.title = element_blank(),
panel.grid = element_blank(),
panel.background = element_rect(size = 1.5,
color = "grey",
fill = "gray95"))
toy_sim_zones_access <- toy_sim_zones_access %>%
mutate(w_j = W_j/number)
toy_sim_zones_access %>%
st_drop_geometry() %>%
filter(type == "jobs") %>%
dplyr::select(id, w_j)
ggplot() +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "jobs"),
aes(fill = w_j, size = w_j, shape = type)) +
geom_sf(data = toy_sim_zones_access %>%
filter(type == "population"),
aes(shape = type),
size = 6, fill = "black") +
geom_sf_text(data = toy_sim_zones_access , aes(label = id_short),
size = 3, nudge_y = -400) +
scale_shape_manual(values = c('population' = 24, 'jobs' = 21), name = "Location Type", labels=c("Population", "Jobs"),
guide = guide_legend(order = 2)) +
scale_size_continuous( range = c(4,9), name = "Spatial Availability \nper Job (w_j)", guide = "none") +
scale_fill_gradient2(low = "goldenrod1",
mid = "white",
high = "darkgreen",
name = "Spatial Availability \nper Job (w_j)",
midpoint = mean(toy_sim_zones_access$w_j, na.rm=T),
guide = guide_colorbar(order = 1)) +
theme(legend.position = "right", axis.text = element_blank(), axis.title = element_blank(),
panel.grid = element_blank(),
panel.background = element_rect(size = 1.5,
color = "grey",
fill = "gray95"))
View(TO_taz_acc)
round(mean(TO_taz_acc$TO_V_i)/mean(TO_taz_acc$worker), 3)
round(mean(TO_taz_acc$TO_V_i), 3)
round(mean(TO_taz_acc$TO_V_i), 3)
