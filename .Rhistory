D3 <- data.frame(i = "A|B|C",
"1" = c(D$D_j[1]),
"2" = c(D$D_j[2]),
"3" = c(D$D_j[3]))
colnames(D3) <- c("k/j", "1", "2", "3")
# D1[nrow(D1) + 1,] = list("D_j at A,B,C", D$D_j[1], D$D_j[2], D$D_j[3])
knitr::kable(list(D1,D3),
format = "html",
booktabs = TRUE,
digits = 2) %>%
kable_styling(font_size = 13)
knitr::kable(S,
format = "html",
booktabs = TRUE,
digits = 2)
#Demand by _origin_
D_i <- od_tt |>
group_by(i) |>
summarize(D_i = sum(pop * f),
.groups = "drop")
S_i <- S |>
pull(S_i)
# Workers traveling for jobs from each zone
nominal_jobs <- S |>
mutate(nominal_jobs = S_i * c(50000,
150000,
10000)) |>
pull(nominal_jobs)
D <-(D_i$D_i)
# Workers traveling for jobs from each zone
nominal_demanded_jobs <- S |>
mutate(nominal_demanded_jobs = S_i * D_i$D_i) |>
pull(nominal_demanded_jobs)
t1 <- data.frame(i = c("A", "B", "C"),
S_i = S_i %>% round(digits = 2),
P_i = c("50000", "150000", "10000"), #workers at each origin center
S_ixP_i=nominal_jobs %>% round(digits = 2)) #jobs demanded for at each origin center
t1[nrow(t1) + 1,] = list("TOTAL", "3.22", "210000","210000")
#opportunities for using in the table
O_j <- od_tt |>
group_by(j) |>
summarize(O_j = mean(opp),
.groups = "drop")
t2 <- data.frame(O_j = O_j)
t2[nrow(t2) + 1,] = list("TOTAL","210000")
colnames(t1) <- c("i", "S_i", "P_i", "S_i*P_i")
colnames(t2) <- c("j", "O_j")
knitr::kable(list(t1,t2),
format = "html",
booktabs = TRUE,
digits = 2)
S_i
library(ggspatial) # Spatial Data Framework for ggplot2
knitr::opts_chunk$set(
echo = FALSE,
cache = FALSE,
warning = FALSE,
message = FALSE,
comment = '',
out.width = "1\\linewidth")
library(dplyr) # A Grammar of Data Manipulation
library(fitdistrplus) # Help to Fit of a Parametric Distribution to Non-Censored or Censored Data
library(geomtextpath) # Curved Text in 'ggplot2'
library(ggforce) # Accelerating 'ggplot2'
library(ggplot2) # Create Elegant Data Visualisations Using the Grammar of Graphics
library(ggpmisc) # Miscellaneous Extensions to 'ggplot2'
library(ggrepel) # Automatically Position Non-Overlapping Text Labels with 'ggplot2'
library(ggspatial) # Spatial Data Framework for ggplot2
library(gridExtra) # Miscellaneous Functions for "Grid" Graphics
library(huxtable) # Easily Create and Style Tables for LaTeX, HTML and Other Formats
library(kableExtra) # Construct Complex Table with 'kable' and Pipe Syntax
library(patchwork) # The Composer of Plots
library(RColorBrewer) # ColorBrewer Palettes
library(sf) # Simple Features for R
library(scales) # Scale Functions for Visualization
library(shadowtext) # Shadow Text Grob and Layer
library(skimr) # Compact and Flexible Summaries of Data
library(spdep) # Spatial Dependence: Weighting Schemes, Statistics
library(tidyr) # Tidy Messy Data
library(tmap) # Thematic Maps
library(TTS2016R) # An augmented 2016 Transportation Tomorrow Survey (TTS) data package
options(scipen = 999)
#defining the spatial availability function
sp_avail <- function(x, o_id, d_id, pop, opp, r, f, alpha = 1){
o_id <- rlang::enquo(o_id)
d_id <- rlang::enquo(d_id)
pop <- rlang::enquo(pop)
opp <- rlang::enquo(opp)
r <- rlang::enquo(r)
f <- rlang::enquo(f)
# Sum of population in system
sum_pop <- x %>%
dplyr::distinct(!!o_id,
.keep_all = TRUE) %>%
dplyr::mutate(sum_pop = !!r*(!!pop)^alpha) %>%
dplyr::pull(sum_pop) %>%
sum()
# Balancing factor size
f_p <- dplyr::pull(x, !!r) * dplyr::pull(x, !!pop)^alpha / sum_pop
# Sum of impedance
sum_impedance <- x %>%
dplyr::group_by(!!d_id) %>%
dplyr::summarize(sum_impedance = sum(!!f))
# Join sum of impedance to table
x <- x %>%
dplyr::left_join(sum_impedance,
by = rlang::as_name(d_id))
# Balancing factor impedance
f_c <- dplyr::pull(x, !!f) / x$sum_impedance
# Add balancing factors to table
x$f_c <- f_c
x$f_p <- f_p
# Sum of balancing factors for mass and impedance
sum_pa <- x %>%
dplyr::group_by(!!d_id) %>%
dplyr::summarize(sum_pa= sum(f_p * f_c))
x <- x %>%
dplyr::left_join(sum_pa,
by = rlang::as_name(d_id))
# Joint balancing factor
f_t <- (f_p * f_c) / dplyr::pull(x, sum_pa)
dplyr::pull(x, !!opp) * f_t
}
#detailed
sp_avail_detailed <- function(x, o_id, d_id, pop, opp, r, f, alpha = 1){
o_id <- rlang::enquo(o_id)
d_id <- rlang::enquo(d_id)
pop <- rlang::enquo(pop)
opp <- rlang::enquo(opp)
r <- rlang::enquo(r)
f <- rlang::enquo(f)
sum_pop <- x %>%
dplyr::distinct(!!o_id,
.keep_all = TRUE) %>%
dplyr::mutate(sum_pop = !!r*(!!pop)^alpha) %>%
dplyr::pull(sum_pop) %>%
sum()
f_p <- dplyr::pull(x, !!r) * dplyr::pull(x, !!pop)^alpha / sum_pop
sum_impedance <- x %>%
dplyr::group_by(!!d_id) %>%
dplyr::summarize(sum_impedance = sum(!!f))
x <- x %>%
dplyr::left_join(sum_impedance,
by = rlang::as_name(d_id))
f_c <- dplyr::pull(x, !!f) / x$sum_impedance
x$f_c <- f_c
x$f_p <- f_p
sum_pa <- x %>%
dplyr::group_by(!!d_id) %>%
dplyr::summarize(sum_pa= sum(f_p * f_c))
x <- x %>%
dplyr::left_join(sum_pa,
by = rlang::as_name(d_id))
x$f_t <- (f_p * f_c) / dplyr::pull(x, sum_pa)
x %>%
dplyr::mutate(V_ij = !!opp * f_t)
}
od_tt <- data.frame(i = c("A", "A", "A", "B", "B", "B", "C", "C", "C"), # Three origins
j = c("1", "2", "3", "1", "2", "3", "1", "2", "3"), # Three destinations
tt = c(15, 30, 100, 30, 15, 100, 100, 100, 15), # Travel time
pop = c(50000, 50000, 50000, 150000, 150000, 150000, 10000, 10000, 10000), # Population
opp = c(100000, 100000, 10000, 100000, 100000, 10000, 100000, 100000, 10000)) # Jobs
od <- data.frame(id = c("A", "B", "C", "1", "2", "3"),
type = c("Population", "Population", "Population", "Jobs", "Jobs", "Jobs"),
size = c(50000, 150000, 10000, 100000, 100000, 10000),
x = c(2.5, 2.5, 6.5, 0.5, 0.5, 6.5),
y = c(7.5, 2.5, 4.5, 7.5, 2.5, 2.5))
centers <- data.frame(id = c("Urban center", "Suburb", "Satellite town"),
radius = rep(1.3, 3),
x = c(1.5, 1.5, 6.5),
y = c(2.5, 7.5, 3.5))
# od_lines coded as segments
od_lines <- data.frame(x = c(2.5, 2.5, 2.5, 2.5, 2.5, 2.5, 6.5, 6.5, 6.5),
y = c(7.5, 7.5, 7.5, 2.5, 2.5, 2.5, 4.5, 4.5, 4.5),
xend = c(0.5, 0.5, 6.5, 0.5, 0.5, 6.5, 0.5, 0.5, 6.5),
yend = c(7.5, 2.5, 2.5, 7.5, 2.5, 2.5, 7.5, 2.5, 2.5),
group = c("A", "A", "A", "B", "B", "B", "C", "C", "C"),
time = c("15 min", "30 min", "100 min",
"30 min", "15 min", "100 min",
"100 min", "100 min", "15 min"),
curvature = c(0.5, 0.5, -0.2, 0.5, 0.5, 0.5, 0.5, 0.5, -0.1))
od_table <- data.frame(Center = c("A", "B", "C", "1", "2", "3"),
Size = c("50,000 pop", "150,000 pop", "10,000 pop", "100,000 jobs", "100,000 jobs", "10,000 jobs"))
od_table2 <- data.frame(Path = c("A to 1", "A to 2", "A to 3",
"B to 1", "B to 2", "B to 3",
"C to 1", "C to 2", "C to 3"),
Value = c("15 mins", "30 mins", "100 mins", "30 mins", "15 mins", "100 mins", "100 mins", "100 mins", "15 mins"))
ggplot() +
# Plot centers
geom_circle(data = centers,
aes(x0 = x,
y0 = y,
r = radius)) +
annotate(geom = "label",
x=c(0.5, 0.6, 7),
y=c(9, 1, 5.2),
label = c("Suburban", "Urban", "Satellite"),
size=4,
label.size=NA) +
# Connect origins and destinations with curves
geom_curve(data = od_lines,
aes(x = x,
y = y,
xend = xend,
yend = yend,
linetype = group,
group = group),
curvature = 0.25,
size = 0,
arrow = arrow(length = unit(0.03, unit = "npc"))) +
# Text on curves
geom_textcurve(data = od_lines,
aes(x = x,
y = y,
xend = xend,
yend = yend,
linetype = group,
group = group,
label = time),
curvature = 0.25,
size = 3) +
# Plot origins and destinations
geom_point(data = od,
aes(size = size,
x = x,
y = y,
color = type,
shape = type)) +
scale_size(range = c(4, 10)) +
# Label origins and destinations
geom_text(data = od,
aes(x,
y,
label=id),
size=4) +
# Create table
annotate(geom = "table",
x = 8,
y = 9,
label = list(od_table),
fill = "white",
size=3) +
# Theme the plot
coord_fixed() +
theme_void() +
guides(shape = "none", size = "none", color = "none", linetype ="none")
#table with all the accessibility calculations
# Impedance parameter
b <- 0.1
# Calculate impedance function
od_tt <- od_tt %>% mutate(f = exp(-b * tt))
# Level of service
LOS_j <- od_tt %>%
group_by(j) %>%
summarize(opp = mean(opp),
R_j = sum(pop * f),
.groups = "drop") %>%
mutate(LOS_j = opp/R_j)
# Hansen- and Shen-type accessibility
S <- od_tt %>%
left_join(LOS_j %>%
dplyr::select(j, LOS_j, opp, R_j),
by = "j") %>%
group_by(i) %>%
summarize(S_i = sum(opp.x * f), #first, hansen-type accessibility (unconstrained)
a_i = sum(LOS_j * f)) #second, shen/2SFCA (singly constrained)
od_tt1 <- merge(od_tt,
S,
by="i",
all.x = TRUE) %>%
transmute(i,
pop,
j,
opp,
tt,
f,
pop_f = pop * f,
jobs_f = opp * f,
S_i,
a_i)%>%
mutate(f = ifelse(f < 0.001, "< 0.001", round(f, 3)),
pop_f = ifelse(pop_f < 0.001, "< 0.001", round(pop_f, 3)),
jobs_f = ifelse(jobs_f < 0.001, "< 0.001", round(jobs_f, 3)))
colnames(od_tt1) = c("Origin", "Pop.", "Dest.", "Jobs", "TT", "f(TT)", "Pop * f(TT)", "Jobs * f(TT)", "S_i", "a_i") #, "BFCA_i")
# Impedance parameter
b <- 0.6
# Calculate impedance function
od_tt <- od_tt %>% mutate(f = exp(-b * tt))
# Level of service
LOS_j <- od_tt %>%
group_by(j) %>%
summarize(opp = mean(opp),
R_j = sum(pop * f),
.groups = "drop") %>%
mutate(LOS_j = opp/R_j)
# Hansen- and Shen-type accessibility
S <- od_tt %>%
left_join(LOS_j %>%
dplyr::select(j, LOS_j, opp, R_j),
by = "j") %>%
group_by(i) %>%
summarize(S_i = sum(opp.x * f), #first, hansen-type accessibility (unconstrained)
a_i = sum(LOS_j * f)) #second, shen/2SFCA (singly constrained),
od_tt2 <- merge(od_tt,
S,
by="i",
all.x = TRUE) %>%
transmute(i,
pop,
j,
opp,
tt,
f,
pop_f = pop * f,
jobs_f = opp * f,
S_i,
a_i) %>%
mutate(f = ifelse(f < 0.001, "< 0.001", round(f, 3)),
pop_f = ifelse(pop_f < 0.001, "< 0.001", round(pop_f, 3)),
jobs_f = ifelse(jobs_f < 0.001, "< 0.001", round(jobs_f, 3)))
colnames(od_tt2) = c("Origin", "Pop.", "Dest.", "Jobs", "TT", "f(TT)", "Pop * f(TT)", "Jobs * f(TT)", "S_i", "a_i") #, "BFCA_i")
#merge 1 and 2 and 3
od_tt3 <- rbind(od_tt1, od_tt2)
od_tt3 <- od_tt3  %>%
as_hux(scientific=TRUE)
#table with all the accessibility calculations
# Impedance parameter
b <- 0.1
# Calculate impedance function
od_tt1 <- od_tt %>% mutate(f = exp(-b * tt))
# Level of service
LOS_j <- od_tt1 %>%
group_by(j) %>%
summarize(opp = mean(opp),
R_j = sum(pop * f),
.groups = "drop") %>%
mutate(LOS_j = opp/R_j)
# Hansen- and Shen-type accessibility
S <- od_tt1 %>%
left_join(LOS_j %>%
dplyr::select(j, LOS_j, opp, R_j),
by = "j") %>%
group_by(i) %>%
summarize(S_i = sum(opp.x * f), #first, hansen-type accessibility (unconstrained)
a_i = sum(LOS_j * f)) #second, shen/2SFCA (singly constrained)
od_tt1 <- merge(od_tt1,
S,
by="i",
all.x = TRUE) %>%
transmute(i,
j,
pop,
opp,
tt,
f,
pop_f = pop * f,
jobs_f = opp * f,
S_i,
a_i)%>%
mutate(f = ifelse(f < 0.001, "< 0.001", round(f, 3)),
pop_f = ifelse(pop_f < 0.001, "< 0.001", round(pop_f, 3)),
jobs_f = ifelse(jobs_f < 0.001, "< 0.001", round(jobs_f, 3)))
colnames(od_tt1) = c("Origin",  "Dest.","Pop.", "Jobs", "TT", "f(TT)", "Pop * f(TT)", "Jobs * f(TT)", "S_i", "a_i") #, "BFCA_i")
od_tt1 <- t(od_tt1)
# Impedance parameter
b <- 0.6
# Calculate impedance function
od_tt2 <- od_tt %>% mutate(f = exp(-b * tt))
# Level of service
LOS_j <- od_tt2 %>%
group_by(j) %>%
summarize(opp = mean(opp),
R_j = sum(pop * f),
.groups = "drop") %>%
mutate(LOS_j = opp/R_j)
# Hansen- and Shen-type accessibility
S <- od_tt2 %>%
left_join(LOS_j %>%
dplyr::select(j, LOS_j, opp, R_j),
by = "j") %>%
group_by(i) %>%
summarize(S_i = sum(opp.x * f), #first, hansen-type accessibility (unconstrained)
a_i = sum(LOS_j * f)) #second, shen/2SFCA (singly constrained),
od_tt2 <- merge(od_tt2,
S,
by="i",
all.x = TRUE) %>%
transmute(f,
pop_f = pop * f,
jobs_f = opp * f,
S_i,
a_i) %>%
mutate(f = ifelse(f < 0.001, "< 0.001", round(f, 3)),
pop_f = ifelse(pop_f < 0.001, "< 0.001", round(pop_f, 3)),
jobs_f = ifelse(jobs_f < 0.001, "< 0.001", round(jobs_f, 3)))
colnames(od_tt2) = c("f(TT)", "Pop * f(TT)^1", "Jobs * f(TT)^1", "S_i^1", "a_i^1") #, "BFCA_i")
od_tt2 <- t(od_tt2)
# Reset impedance parameter
b <- 0.1
# Calculate impedance function
od_tt3 <- od_tt %>%
mutate(f = exp(-b * tt))
od_tt3 <- od_tt3 %>%
mutate(catch = 1) %>%
sp_avail_detailed(o_id = i, #spatial availability
d_id = j,
pop = pop,
opp = opp,
r = catch,
f = f,
alpha = 1) %>%
transmute(i,
f,
F_p = f_p,
F_c = f_c,
F_t = f_t,
V_ij)
V_i <- od_tt3 %>%
group_by(i) %>%
summarize(V_i = sum(V_ij))
od_tt3 <- od_tt3 %>%
left_join(V_i,
by = "i") %>% dplyr::select(-c(i,f)) %>%
mutate(F_p = ifelse(F_p < 0.001, "< 0.001", round(F_p, 3)),
F_c = ifelse(F_c < 0.001, "< 0.001", round(F_c, 3)),
F_t = ifelse(F_t < 0.001, "< 0.001", round(F_t, 3)),
V_ij = ifelse(V_ij < 0.001, "< 0.001", round(V_ij, 3)),
V_i = ifelse(V_i < 0.001, "< 0.001", round(V_i, 3)),)
colnames(od_tt3) <- c("F^p", "F^c", "F", "V_ij", "V_i")
od_tt3 <- t(od_tt3)
#merge 1 and 2 and 3
od_tt4 <- rbind(od_tt1, od_tt2, od_tt3)
rownames_od_tt4 <- c("Origin",
"Dest.", "Pop.", "Jobs", "TT",
"f(TT)", "Pop * f(TT)", "Jobs * f(TT)", "S_i", "a_i",
"f(TT)", "Pop * f(TT)", "Jobs * f(TT)", "S_i", "a_i",
"F^c", "F^p", "F", "V_ij", "V_i")
od_tt4 <- cbind(rownames_od_tt4, od_tt4)
od_tt4 <- od_tt4  %>%
as_hux()
table_toy  <- od_tt4 %>%
set_background_color(c(6:10,16:20), 1:10, "lightyellow") %>%
set_background_color(11:15, 1:10, "grey90") %>%
set_bold(1:2, everywhere) %>%
set_bottom_border(c(1,2,5,10,15,20), everywhere) %>%
set_right_border(everywhere, c(1,4,7,10), brdr(1, "solid", "grey")) %>%
set_align(1:20, 1, "left") %>%
set_align(1:20,  2:10, "center") %>%
set_number_format(c(6,10,11:15,16:18), everywhere, 3) %>% #the smaller numbers, have 3 decimals
set_number_format(c(7:9,19,20), everywhere, 1) %>% # the larger numbers, have 1 decimal
merge_cells(1, 2:4) %>% merge_cells(1, 5:7) %>% merge_cells(1, 8:10) %>%
set_caption("Summary description of synthetic example: Hansen-type accessibility $S_i$, Shen-type accessibility $a_i$, and spatial availability $V_i$ with beta = 0.1 (light yellow) and beta = 0.6 (light grey).") %>%
set_label("tab:synthetic-example") %>%
set_latex_float("h!") %>%
set_width(1.1)
font_size(table_toy) <- 7
table_toy[1:20,]
b<-0.6
data.frame(tt = seq(0, 110, 1)) %>%
mutate(f1 = exp(-0.1 * tt),
f2 = exp(-b * tt)) %>%
pivot_longer(cols = -tt,
names_to = "Function",
values_to = "f") %>%
mutate(Function = case_when(Function == "f1" ~ "beta = 0.1",
Function == "f2" ~ "beta = 0.6")) %>%
ggplot() +
xlab("TT") +
ylab("f(TT)") +
geom_line(aes(x = tt,
y = f,
color = Function)) +
theme_minimal()
V_i$V_i[1]/50000
V_i$V_i[2]/150000
V_i$V_i[3]/10000
# grouping the planning boundaries/municipalities so they make up the 20 regions in the TTS 2016. Note: st_buffer is used as there are small existing gaps between some boundaries. st_buffer of 100 m is enough to widen all boundaries and complete the st_union without issue.
group_ggh_pd_poly <- TTS2016R::ggh_pd %>% st_buffer(100) %>% group_by(REGION) %>%
summarize(REGION_name = first(REGION_name),
geometry = st_union((geometry)))
# creating an object of centroids for each region - this will be used to label polygons on the map
group_ggh_pd <- sf::st_centroid(group_ggh_pd_poly)
points <- sf::st_coordinates(group_ggh_pd) %>% data.frame()
group_ggh_pd <- cbind(group_ggh_pd, points)
## manually readjusting the X and Y coordinate of "County of Peterborough" and "Brant" as they overlap some cities
group_ggh_pd[group_ggh_pd$REGION_name=="Brant", "X"] <- 544000.0
group_ggh_pd[group_ggh_pd$REGION_name=="Brant", "Y"] <- 4767466
group_ggh_pd[group_ggh_pd$REGION_name=="Peterborough County", "Y"] <- 4921000
#plot
TTS_area_plot <- ggplot() +
geom_sf(data = TTS2016R::ggh_pd, color = "darkgray",
aes(fill = REGION_name)) +
scale_fill_manual(values = viridis::viridis(20)) +
geom_sf(data = group_ggh_pd_poly,
color = "black", fill = NA, size = 0.7) +
annotation_north_arrow(location = "tl", # north arrow for both the main plot
height = unit(0.8, "cm"),
width = unit(0.8, "cm"),
style = north_arrow_orienteering(line_width = 0.25,
line_col = "dimgrey",
fill = c("white","dimgrey"))) +
annotation_scale(bar_cols = c("dimgrey", "white"), # scale bar for both the main plot
height = unit(0.15, "cm")) +
geom_shadowtext(data = group_ggh_pd,
aes(x = X, y = Y, label = REGION_name),
size = 3.5,
nudge_y = 3000,
nudge_x = 2000) +
theme_void() +
theme(legend.position = "none",
axis.title = element_blank())
ggsave("images/TTS16-survey-area-notable.png")
