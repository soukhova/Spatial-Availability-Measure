---
title: "Toy example to experiment with spatial availability"
output: 
---

So Anastasia and I have been experimenting with proportional allocation in accessibility measures, and have discussed the concept of _spatial availability_. Briefly, consider the following accessibility measure:
$$
A_i = \sum_{j=1}^JW_jf(c_{ij})
$$

\noindent where $W_j$ is the number of opportunities at location $j$, $c_{ij}$ is a measure of the cost of moving between $i$ and $j$, and $f(\cdot)$ is an impedance (or distance-decay) function (a monotonically non-increasing or decreasing function of $c_{ij}$). In this way, the accessibility $A_i$ is the weighted sum of opportunities that can be reached from location $i$. It is well known that this is a gravity-type measure of accessibility, and it is a widely used tool in transportation studies.

Accessibility $A_i$, by summing the jobs in the neighborhood of $i$ (the neighborhood is defined by the impedance function), is an estimation of the total number of jobs that can be reached from $i$. 

As we have discussed proportional allocations (see for instance Paez, Higgins, Vivona, 2019), it has become increasingly clear that a lot of multiple-counting happens when calculating $A_i$ for $i=1,\cdots,n$, since every opportunity that can be reached from every $i$ enters the sum.

For this reason, we have thought of a related concept that we are provisionally calling _spatial availability_, and that we think of as a measure of accessibility with capacity constraints.

How does this work? It all comes down to proportional allocation. We wish to allocate jobs proportionally to population, based on the number of jobs and the distance from population.

This is our current framework.

We begin with allocation based on population. Consider an employment center $j$ with $W_j$ jobs and $K$ population centers in the region. To allocate these jobs proportionally based on the population of each center we define the following proportional allocation factor:
$$
f^p_{ij} = \frac{P_j^\alpha}{\sum_{k=1}^K P_k^\alpha}
$$
\noindent where $f^p_{ij}$ is an factor to proportionally allocate a share of the jobs at $j$ to population center $i$ and $P_k$ is the population at location $k$. Here we add a parameter $\alpha$ that can be used to modulate the effect of size in the calculations. The summation in the bottom is over $k=1,\cdots,K$, the number of population centers in the region. The factors $f_{kj}^p$ satisfy the property that $\sum_k^{K} f^p_{kj} = 1$.

The share of jobs allocated to each population center is:
$$
W_{kj} = W_jf^p_{kj}
$$
\noindent and since $\sum_k^{K} f^p_{kj} = 1$ it follows that:
$$
\sum_{k=1}^K W_{kj} = W_j 
$$

In other words, the number of jobs is preserved. As an example, consider an employment center $j$ in a region with two population centers (say $j$ and $k$). The allocation factors for the jobs at $j$ would be:
$$
\begin{array}{l}\
f^p_{ij} = \frac{P_i ^\alpha}{P_i^\alpha + P_k^\alpha}\\
f^p_{kj} = \frac{P_k^\alpha}{P_i^\alpha + P_k^\alpha}\\
\end{array}
$$

Suppose that there are three hundred jobs in the employment center ($W_j = 300$), and that the populations are $P_j=200$ and $P_k=100$. The jobs would be allocated as follows (assuming that $\alpha=1$):
$$
\begin{array}{l}\
W_{ij} = W_j\frac{P_i^\alpha}{P_i^\alpha + P_k^\alpha} = 300\frac{200}{200 + 100} = 300\frac{200}{300} = 200\\
W_{kj} = W_j\frac{P_k^\alpha}{P_i^\alpha + P_k^\alpha} = 300\frac{100}{200 + 100} = 300\frac{100}{300} = 100 \\
\end{array}
$$
\noindent where it can be seen that $\sum_{k=1}^K W_{kj} = W_j$.

These factors account for the capacity of the employment centers, but they do not account for their location relative to the population centers. The proportional allocation procedure above is insensitive to how far population center $i$ is from employment center $j$. To account for this effect we can define a second set of allocation factors based on distance to the employment centers. These are defined as:
$$
f^d_{ij} = \frac{f(c_{ij})}{\sum_{k=1}^K f(c_{kj})}
$$
\noindent where $c_{ij}$ is the distance/(travel time, etc.) to employment center $j$ from population center $i$, and $f(\cdot)$ is an impedance function (a monotonically decreasing function of $c_{kj}$. The idea is that proportionally more jobs are allocated to closer locations. Assume that the impedance function is:
$$
f(c_{ij}) = \exp(-\beta c_{ij})
$$

Continuing the example, suppose that the distance from population center $i$ to employment center $j$ is 0.6 km, and the distance from population center $k$ to employment center $j$ is 0.3 km. Being closer, we would expect more jobs to be allocated to the population of $i$. The jobs would be sorted as follows:
$$
\begin{array}{l}\
f^d_{ij} = \frac{\exp(-\beta D_{ij})}{\exp(-\beta D_{ij}) + \exp(-\beta D_{kj})}\\
f^d_{kj} = \frac{\exp(-\beta D_{kj})}{\exp(-\beta D_{ij}) + \exp(-\beta D_{kj})}\\
\end{array}
$$

Numerically, the jobs allocated to each population center would be:
$$
\begin{array}{l}\
W^d_{ij} = W_j\frac{\exp(-D_{ij})}{\exp(-D_{ij}) + \exp(-D_{kj})} = 300\frac{\exp(-0.6)}{\exp(-0.6) + \exp(-0.3)} = 3\times 0.426 = 127.8\\
W^d_{kj} = W_j\frac{\exp(-D_{kj})}{\exp(-D_{ij}) + \exp(-D_{kj})} = 300\frac{\exp(-0.3)}{\exp(-0.6) + \exp(-0.3)} = 3\times  0.574 = 172.2\\
\end{array}
$$

And the sum of jobs allocated to the population centers matches the total number of jobs available.

We can combine the proportional allocation factors by population and distance as follows:
$$
W_{ij} = W_i\frac{f^p_{ij} \cdot f^d_{ij}}{\sum_{k=1}^K f^p_{kj} \cdot f^d_{kj}}
$$
In the example:
$$
\begin{array}{l}\
W_{ij} = W_j\cdot \frac{f^o_{ij} \cdot f^d_{ij}}{f^o_{ij} \cdot f^d_{ij} + f^o_{kj} \cdot f^d_{kj}} = 300 \frac{\big(\frac{2}{3} \big) \big(0.426 \big)}{\big(\frac{2}{3} \big) \big(0.426 \big) + \big(\frac{1}{3} \big) \big(0.574 \big)} = \big(300 \big)\big(\frac{0.284}{0.475} \big)= 179.4\\
W_{kj} = W_j\cdot \frac{f^o_{kj} \cdot f^d_{kj}}{f^o_{ij} \cdot f^d_{ij} + f^o_{ik} \cdot f^d_{ik}} = 300 \frac{\big(\frac{1}{3} \big) \big(0.574 \big)}{\big(\frac{2}{3} \big) \big(0.426 \big) + \big(\frac{1}{3} \big) \big(0.574 \big)}  = \big(300 \big)\big(\frac{0.191}{0.475} \big)= 120.6 \\
\end{array}
$$

And the sum of jobs at employment center $j$ that are allocated to population centers $i$ and $k$ simultaneously based on _population_ and _distance_ is preserved (i.e., $W_{ij} + W_{kj} = W_j$.

Availability is the sum of available jobs by origin:
$$
V_i = \sum_{j=1}^J W_{ij}
$$

## Numerical Example 

```{r message=FALSE}
library(patchwork)
library(sf)
library(tidyverse)
```

Load data for example:
```{r}
load("od_table.rda")
load("simulated_data.rda")
load("trips.rda")
```

Assume a simple binary impedance function that uses the median distance as a threshold:
$$
f(d_{ij}) = I(d_{ij}\le 3374)
$$

This is implemented in the example as follows. We will assume for this numerical example that $\alpha = 1$:
```{r}
alpha <- 1
```

First, calculate the denominator of the proportional allocation factor $f^p_{ij}$ based on population:
```{r}
sum_pop <- od_table %>%
  distinct(Origin, 
           .keep_all = TRUE) %>%
  mutate(sum_pop = Population^alpha) %>%
  pull(sum_pop) %>%
  sum()
```

Calculate the proportional allocation factor:
```{r}
od_table <- od_table %>%
  mutate(f_p = Population^alpha / sum_pop)
```

Calculate the jobs allocated to each population center from each employment center:
```{r}
od_table <- od_table %>%
  mutate(W_ij = Jobs * f_p)
```

Verify that the sum of all jobs allocated is consistent with the total number of jobs:
```{r}
sum(od_table$W_ij)
```

The total number of jobs is preserved.

```{r}
availability <- od_table %>%
  group_by(Origin) %>%
  summarize(availability = sum(W_ij))
availability
```

Calculate the impedance function and add to OD-table:
```{r}
od_table <- od_table %>%
  mutate(f = ifelse(distance <= 3374, 1, 0))
```

```{r}
sum_impedance <- od_table %>% 
  group_by(Destination) %>% 
  summarize(sum_impedance = sum(f))
sum_impedance
```

Next, join the sums of the impedance to the OD-table:
```{r}
od_table <- od_table %>%
  left_join(sum_impedance,
            by = "Destination")
```

Calculate the proportional allocation factor:
```{r}
od_table <- od_table %>%
  mutate(f_c = f / sum_impedance)
```

Calculate the jobs allocated to each population center from each employment center:
```{r}
od_table <- od_table %>%
  mutate(W_ij = Jobs * f_c)
```

Verify that the sum of all jobs allocated is consistent with the total number of jobs:
```{r}
sum(od_table$W_ij)
```

Combine:
```{r}
sum_pa <- od_table %>% 
  group_by(Destination) %>% 
  summarize(sum_pa= sum(f_p * f_c))
sum_pa
```

Next, join the sums of the impedance to the OD-table:
```{r}
od_table <- od_table %>%
  left_join(sum_pa,
            by = "Destination")
```

Calculate the combined proportional allocation factor:
```{r}
od_table <- od_table %>%
  mutate(f_t = (f_p * f_c) / sum_pa)
```

Calculate the jobs allocated to each population center from each employment center:
```{r}
od_table <- od_table %>%
  mutate(W_ij = Jobs * f_t)
```

Verify that the sum of all jobs allocated is consistent with the total number of jobs:
```{r}
sum(od_table$W_ij)
```

The spatial availability of jobs for each population center is the sum of the jobs proportionally allocated to them from each employment center:
```{r}
availability <- od_table %>%
  group_by(Origin) %>%
  summarize(availability = sum(W_ij))
availability
```

Again, check that the spatial availability is consistent with the total:
```{r}
sum(availability$availability)
```

Pack the proportional allocation of opportunities into a function:
```{r}
p_allocation <- function(x, alpha = 1){
  # The input is an OD-table with Origins, Destinations, Population, Jobs, and a pre-calculated impedance function f
  sum_pop <- x %>%
  distinct(Origin, 
           .keep_all = TRUE) %>%
  mutate(sum_pop = Population^alpha) %>%
  pull(sum_pop) %>%
  sum()

  x <- x %>%
  mutate(f_p = Population^alpha / sum_pop)

  sum_impedance <- x %>% 
    group_by(Destination) %>% 
    summarize(sum_impedance = sum(f))
  sum_impedance
  
  x <- x %>%
    left_join(sum_impedance,
              by = "Destination")
  
  x <- x %>%
    mutate(f_c = f / sum_impedance)
  
  sum_pa <- x %>% 
    group_by(Destination) %>% 
    summarize(sum_pa= sum(f_p * f_c))
  
  x <- x %>%
    left_join(sum_pa,
              by = "Destination")
  
  x <- x %>%
    mutate(f_t = (f_p * f_c) / sum_pa)
  
  x <- x %>%
    mutate(W_ij = Jobs * f_t)
  
  return(x$W_ij)
}
```

Refresh the od_table:
```{r}
load("od_table.rda")
```

Use with the binary impedance function:
```{r}
od_table <- od_table %>%
  mutate(f = ifelse(distance <= 3374, 1, 0))
```

Calculate the proportional allocation of opportunities using this function:
```{r}
od_table <- od_table %>%
  mutate(W_ij_binary = p_allocation(.))
```

Verify that the sum of all jobs allocated is consistent with the total number of jobs:
```{r}
sum(od_table$W_ij_binary)
```

The total number of jobs is preserved.

Repeat the availability calculation:
```{r}
availability <- od_table %>%
  group_by(Origin) %>%
  summarize(avail_binary = sum(W_ij_binary))
availability
```

Join the availability to the simulated_data:
```{r}
simulated_data <- simulated_data %>%
  left_join(availability, 
            by = c("id" = "Origin"))
```

Plot the spatial availability:
```{r}
avail_binary_plot <- ggplot() +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(color = avail_binary,
              size = avail_binary),
          shape = 17) +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(size = avail_binary),
          shape = 2) +
  geom_sf(data = simulated_data %>% 
            filter(type == "jobs"),
          aes(size = number,
              shape = )) +
  scale_color_distiller(palette = "OrRd",
                        direction = 1)

avail_binary_plot
```

Since the number of jobs is preserved, we can calculate the available jobs per person:
```{r}
simulated_data <- simulated_data %>%
  mutate(avail_binary_per_person = avail_binary/number)
```

Plot the availability per person:
```{r}
avail_binary_person_plot <- ggplot() +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(color = avail_binary_per_person,
              size = avail_binary_per_person),
          shape = 17) +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(size = avail_binary_per_person),
          shape = 2) +
  scale_color_gradient2(midpoint = 1)

avail_binary_person_plot
```

What happens if we use a different impedance function? For example:
$$
f(c_{ij}) = exp(-\beta c_{ij})
$$

This is the shape of this function (the rate of decay is modulated by $\beta$):
```{r}
beta <- 0.0005
data.frame(d_ij = seq(600, 7800, 50)) %>%
  mutate(f = exp(-beta * d_ij)) %>%
  ggplot() +
  geom_line(aes(x = d_ij, y = f))
```

Recalculate the impedance function in the OD-table:
```{r}
od_table <- od_table %>%
  mutate(f = exp(-beta * distance))
```

Calculate the proportional allocation of opportunities using this function:
```{r}
od_table <- od_table %>%
  mutate(W_ij_exp1 = p_allocation(.))
```

Verify that the sum of all jobs allocated is consistent with the total number of jobs:
```{r}
sum(od_table$W_ij_exp1)
```

The total number of jobs is preserved.

Repeat the availability calculation:
```{r}
availability <- od_table %>%
  group_by(Origin) %>%
  summarize(avail_exp1 = sum(W_ij_exp1))
availability
```

Join the availability to the simulated_data:
```{r}
simulated_data <- simulated_data %>%
  left_join(availability, 
            by = c("id" = "Origin"))
```

Plot the two availability estimates:
```{r fig.height=6}
avail_exp1_plot <- ggplot() +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(color = avail_exp1,
              size = avail_exp1),
          shape = 17) +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(size = avail_exp1),
          shape = 2) +
  geom_sf(data = simulated_data %>% 
            filter(type == "jobs"),
          aes(size = number,
              shape = )) +
  scale_color_distiller(palette = "OrRd",
                        direction = 1)

avail_binary_plot/avail_exp1_plot
```

Available jobs per person using exponential impedance:
```{r}
simulated_data <- simulated_data %>%
  mutate(avail_exp1_per_person = avail_exp1/number)
```

Plot the availability per person:
```{r fig.height=6}
avail_exp1_person_plot <- ggplot() +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(color = avail_exp1_per_person,
              size = avail_exp1_per_person),
          shape = 17) +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(size = avail_exp1_per_person),
          shape = 2) +
  scale_color_gradient2(midpoint = 1)

avail_binary_person_plot / avail_exp1_person_plot

```
How does the distribution of people to jobs compare to the trips matrix?
```{r}
data.frame(trips = trips$trips, binary = od_table$W_ij_binary, exp1 = od_table$W_ij_exp1) %>%
  cor()
```

Scatterplots:
```{r fig.height=6, fig.width=6}
scatter_binary <- data.frame(trips = trips$trips, 
           W_ij = od_table$W_ij_binary) %>%
  ggplot() +
  geom_point(aes(x = trips, y = W_ij)) +
  geom_abline(slope = 1, intercept = 0)

scatter_exp1 <- data.frame(trips = trips$trips, 
           W_ij = od_table$W_ij_exp1) %>%
  ggplot() +
  geom_point(aes(x = trips, y = W_ij)) +
  geom_abline(slope = 1, intercept = 0)

scatter_binary / scatter_exp1
```

Explore values of $\beta$:
```{r}
beta <- seq(0.0005, 0.005, 0.0001)
cor_beta <- vector(length = length(beta))
mad_beta <- vector(length = length(beta))

for(i in 1:length(beta)){
  od_exp <- od_table %>%
    mutate(f = exp(-beta[i] * distance))
   junk <- data.frame(trips = trips$trips, 
              W_ij = p_allocation(od_exp)) %>% 
     cor()
   cor_beta[i] <- junk[2,1]
  junk <- abs(trips$trips - p_allocation(od_exp))
  mad_beta[i] <- max(junk)
}

data.frame(beta = beta, correlation = cor_beta) %>%
  ggplot() +
  geom_line(aes(x = beta, y = correlation))

data.frame(beta = beta, mad = mad_beta) %>%
  ggplot() +
  geom_line(aes(x = beta, y = mad))
```

Parameter according to the correlation:
```{r}
beta[which(cor_beta == max(cor_beta))]
```

Parameter according to the maximum absolute deviation:
```{r}
beta[which(mad_beta == min(mad_beta))]
```

Use beta = 0.0011

Recalculate the impedance function in the OD-table:
```{r}
od_table <- od_table %>%
  mutate(f = exp(-0.0011 * distance))
```

Calculate the proportional allocation of opportunities using this function:
```{r}
od_table <- od_table %>%
  mutate(W_ij_exp2 = p_allocation(.))
```

Verify that the sum of all jobs allocated is consistent with the total number of jobs:
```{r}
sum(od_table$W_ij_exp2)
```

Compare to actual trip distribution:
```{r}
scatter_exp2 <- data.frame(trips = trips$trips, 
           W_ij = od_table$W_ij_exp2) %>%
  ggplot() +
  geom_point(aes(x = trips, y = W_ij)) +
  geom_abline(slope = 1, intercept = 0)

scatter_exp2
```

Repeat the availability calculation:
```{r}
availability <- od_table %>%
  group_by(Origin) %>%
  summarize(avail_exp2 = sum(W_ij_exp2))
availability
```

Join the availability to the simulated_data:
```{r}
simulated_data <- simulated_data %>%
  left_join(availability, 
            by = c("id" = "Origin"))
```

Plot the availability estimates:
```{r}
avail_exp2_plot <- ggplot() +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(color = avail_exp1,
              size = avail_exp1),
          shape = 17) +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(size = avail_exp1),
          shape = 2) +
  geom_sf(data = simulated_data %>% 
            filter(type == "jobs"),
          aes(size = number,
              shape = )) +
  scale_color_distiller(palette = "OrRd",
                        direction = 1)

avail_exp2_plot
```

Available jobs per person using exponential impedance and $\beta = 0.0011$:
```{r}
simulated_data <- simulated_data %>%
  mutate(avail_exp2_per_person = avail_exp2/number)
```

Plot the availability per person:
```{r}
avail_exp2_person_plot <- ggplot() +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(color = avail_exp2_per_person,
              size = avail_exp2_per_person),
          shape = 17) +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(size = avail_exp1_per_person),
          shape = 2) +
  scale_color_gradient2(midpoint = 1)

avail_exp2_person_plot
```

Explore values of $\alpha$ and $\beta$:
```{r}
beta <- seq(0.001, 
            0.0045, 
            length.out = 50)
alpha <- seq(0.1, 
             3, 
             length.out = 50)
cor_hp <- vector(length = length(beta) * length(alpha))
mad_hp <- vector(length = length(beta) * length(alpha))
hyper_parameters <- data.frame(expand.grid(alpha = alpha, 
                                           beta = beta),
                               cor_hp,
                               mad_hp)
counter <- 0

for(b in 1:length(beta)){
  od_exp <- od_table %>%
      mutate(f = exp(-beta[b] * distance))
  for(a in 1: length(alpha)){
    counter <- counter + 1
    junk <- data.frame(trips = trips$trips, 
                       W_ij = p_allocation(od_exp,
                                           alpha = alpha[a])) %>% 
      cor()
   hyper_parameters$cor_hp[counter] <- junk[2,1]
   junk <- abs(trips$trips - p_allocation(od_exp, 
                                          alpha = alpha[a]))
   hyper_parameters$mad_hp[counter] <- max(junk)
  }
}
```


```{r}
ggplot(data = hyper_parameters, aes(x = alpha, y = beta, z = cor_hp)) +
  geom_contour_filled()

```

```{r}
ggplot(data = hyper_parameters, aes(x = alpha, y = beta, z = mad_hp)) +
  geom_contour_filled()

```

Check combination of hyperparameters that maximizes the correlation:
```{r}
hyper_parameters %>%
  filter(cor_hp == max(cor_hp))
```

Check combination of hyperparameters that minimizes the maximum absolute deviation:
```{r}
hyper_parameters %>%
  filter(mad_hp == min(mad_hp))
```

Use alpha = 0.1 and beta = 0.0025

Recalculate the impedance function in the OD-table:
```{r}
od_table <- od_table %>%
  mutate(f = exp(-0.0025* distance))
```

Calculate the proportional allocation of opportunities using these parameters:
```{r}
od_table <- od_table %>%
  mutate(W_ij_best = p_allocation(.,
                                  alpha = 0.1))
```

Verify that the sum of all jobs allocated is consistent with the total number of jobs:
```{r}
sum(od_table$W_ij_best)
```

Compare to actual trip distribution:
```{r}
scatter_best <- data.frame(trips = trips$trips, 
           W_ij = od_table$W_ij_best) %>%
  ggplot() +
  geom_point(aes(x = trips, y = W_ij)) +
  geom_abline(slope = 1, intercept = 0)

(scatter_binary + scatter_exp1) / (scatter_exp2 + scatter_best)
```

Repeat the availability calculation:
```{r}
availability <- od_table %>%
  group_by(Origin) %>%
  summarize(avail_best = sum(W_ij_best))
availability
```

Join the availability to the simulated_data:
```{r}
simulated_data <- simulated_data %>%
  left_join(availability, 
            by = c("id" = "Origin"))
```

Plot the availability estimates:
```{r}
avail_best_plot <- ggplot() +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(color = avail_best,
              size = avail_best),
          shape = 17) +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(size = avail_best),
          shape = 2) +
  geom_sf(data = simulated_data %>% 
            filter(type == "jobs"),
          aes(size = number,
              shape = )) +
  scale_color_distiller(palette = "OrRd",
                        direction = 1)

avail_best_plot
```

Available jobs per person using exponential impedance and $\beta = 0.0011$:
```{r}
simulated_data <- simulated_data %>%
  mutate(avail_best_per_person = avail_best/number)
```

Plot the availability per person:
```{r}
avail_best_person_plot <- ggplot() +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(color = avail_best_per_person,
              size = avail_best_per_person),
          shape = 17) +
  geom_sf(data = simulated_data %>% 
            filter(type == "population"),
          aes(size = avail_best_per_person),
          shape = 2) +
  scale_color_gradient2(midpoint = 1)

avail_best_person_plot
```


Compare the impedance curves:
```{r fig.height=6, fig.width=6}
data.frame(d_ij = seq(600, 7800, 50)) %>%
  mutate(binary = ifelse(d_ij <= 3374, 1, 0),
         b_0005 = exp(-0.0005 * d_ij),
         b_0011 = exp(-0.0011 * d_ij),
         b_best = exp(-0.0025 * d_ij)) %>%
  pivot_longer(cols = starts_with("b"), names_to = "beta", values_to = "f") %>%
  mutate(beta = factor(beta,
                       levels = c("binary", "b_0005", "b_0011", "b_best"),
                       ordered = TRUE)) %>%
  ggplot() +
  geom_line(aes(x = d_ij, y = f)) +
    facet_wrap(~ beta, ncol = 2)
```

Compare availability per person with the three impedance functions:
```{r fig.height=6, fig.width=12}
(avail_binary_person_plot + avail_exp1_person_plot) / (avail_exp2_person_plot + avail_best_person_plot)
```
