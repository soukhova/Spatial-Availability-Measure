<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Estimating spatial availability/mismatch using singly constrained accessibility measures</title>
    <meta charset="utf-8" />
    <meta name="author" content="Anastasia Soukhov, etc." />
    <meta name="date" content="2022-01-22" />
    <script src="Presentation_files/header-attrs-2.11/header-attrs.js"></script>
    <link href="Presentation_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="Presentation_files/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Estimating spatial availability/mismatch using singly constrained accessibility measures
## Planning
### Anastasia Soukhov, etc.
### 2022-01-22

---



# Background

- Conventional accessibility is widely used and is defined as follows:

`$$A_i = \sum_{j=1}^JO_jf(c_{ij})$$`

Where:

-   `\(A\)` is accessibility. 
-   `\(i\)` is a set of origin locations.
-   `\(j\)` is a set of destination locations.
-   `\(O_j\)` is the number of opportunities at location `\(j\)`. These are opportunities for activity and add some sort of *supply* to the area;
-   `\(c_{ij}\)` is a measure of the cost of moving between `\(i\)` and `\(j\)`
-   `\(f(\cdot)\)` is an impedance function of `\(c_{ij}\)`; it can take the form of any monotonically decreasing function (e.g., negative exponential distribution) .

---

# Background: Accessibility




&lt;img src="Presentation_files/figure-html/unnamed-chunk-1-1.png" style="display: block; margin: auto;" /&gt;
-   higher accessibility of population centers (triangles) which are closer to the two larger employment centers.

-   Remote population centers near the left edge of the map have the lowest levels of job accessibility as they are only in proximity to the small employment center.

---

# Background: Issues with Accessibility

- conglomeration effect - multiple-counting of opportunities (jobs) results in unclear interpretability; for instance, P5 has an accessibility score of 600 meaning that population center of 490 workers has access to 600 jobs. This makes sense as P5 is very close to a large employment center. The assumption here is that this opportunity is divisible and non-competitive meaning that if a densely populated population center pops up next to P5 - it too will have a high accessibility score. Conventional accessibility does not consider competition of opportunities (jobs) from neighbouring demand (population centers). This neglect of opportunity-constrainted (single-constrained) competition obscures the interpretability of conventional accessibility which may  manifests in the following two ways of biased estimation:

1) less dense urban periphery demand centers may be assigned disproportionately _high_ accessibility values. These periphery areas are located right outside dense urban demand centers and large urban opportunity centeres and thus may have low travel cost to these large opportunity centers. Accessibility does not consider opportunity-constraints and as such these periphery demand centers benefit from the high accessibility to opportunities without competition considerations from their more dense and centrally located neighbours.

2) remote/isolated areas which are still within the region of the analysis and have regionally-relative low demand centers, opportunity centers, and travel cost to opportunity centers, are assigned disproportionately _low_ accessibility values. These remote/isolated areas may be sufficiently supplied with opportunities proportionate to their demand but is obscured by the artificially high accessibility awarded to periphery/other areas in which conglomeration disproportionally occurs. 

---

# Ideas
- maybe remove the use cases? Or change their order? 

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"slideNumberFormat": "%current% / X",
"highlightStyle": "github",
"highlightLines": true,
"ratio": "16:9",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
